
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fractal Worlds — Mandelbrot Levels (Trippy Sky Upgrade)</title>
<style>
  html,body{height:100%;margin:0;background:#05050a;overflow:hidden;font-family:Inter,Arial,Helvetica,sans-serif}
  #ui{position:fixed;left:12px;top:12px;z-index:90;background:rgba(8,8,12,0.92);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);color:#ddd;width:320px}
  #ui input,#ui button{background:#111;color:#ddd;border:1px solid #333;padding:8px;margin-top:8px;display:block;width:100%}
  #mandel{display:block;margin-top:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);cursor:crosshair;image-rendering:pixelated}
  #info{font-size:12px;color:#9fd;margin-top:8px}
  #fps{position:fixed;right:12px;top:12px;color:#fff;z-index:90;font-weight:700}
  .crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none;z-index:92}
  .crosshair::after{content:'';display:block;width:2px;height:18px;background:#fff;transform:translateX(-1px);opacity:0.95}
  .crosshair::before{content:'';display:block;width:18px;height:2px;background:#fff;transform:translateY(-1px);opacity:0.95}
  #weaponCanvas{position:fixed;right:18px;bottom:18px;z-index:90;background:rgba(0,0,0,0.45);border-radius:6px}
  #message{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;color:#ddd;z-index:90}
  .small{font-size:12px;color:#aaa;margin-top:6px}
</style>
</head>
<body>
<div id="ui">
  <div><strong>Mandelbrot → Level Generator</strong></div>
  <div>Seed base: <input id="seed" value="1337"></div>
  <div>Base platforms: <input id="platforms" type="number" min="1" max="20" value="6"></div>
  <button id="startBtn">Start / Lock Pointer</button>
  <button id="regenBtn">Generate Level From View</button>
  <canvas id="mandel" width="320" height="320" title="Wheel to zoom, drag to pan, double-click to zoom"></canvas>
  <div id="info">
    <div>Center: <span id="coord">—</span></div>
    <div>Zoom: <span id="zoomLevel">1</span> ×</div>
    <div>Derived Seed: <span id="derivedSeed">—</span></div>
  </div>
  <div class="small">Click Mandelbrot to spawn a full level at that complex coordinate. Zoom deeper to vary level complexity.</div>
</div>

<div id="fps">FPS: 0</div>
<div class="crosshair"></div>
<canvas id="weaponCanvas" width="320" height="120"></canvas>
<div id="message">Click Start, then click to lock. WASD to move, mouse to look, left click to shoot.</div>

<!-- three r149 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>

<!-- PointerLockControls (inline) -->
<script>
class PointerLockControls extends THREE.EventDispatcher {
  constructor(camera, domElement){
    super();
    this.domElement = domElement || document.body;
    this.isLocked = false;
    const scope = this;
    const euler = new THREE.Euler( 0, 0, 0, 'YXZ' );
    const PI_2 = Math.PI/2;
    function onMouseMove(e){
      if(!scope.isLocked) return;
      const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
      const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
      euler.setFromQuaternion(camera.quaternion);
      euler.y -= movementX * 0.0022;
      euler.x -= movementY * 0.0022;
      euler.x = Math.max(PI_2 - scope.maxPolarAngle, Math.min(PI_2 - scope.minPolarAngle, euler.x));
      camera.quaternion.setFromEuler(euler);
    }
    function onPointerlockChange(){
      scope.isLocked = (document.pointerLockElement === scope.domElement);
      scope.dispatchEvent({type: scope.isLocked ? 'lock' : 'unlock'});
    }
    function onPointerlockError(){ console.error('PointerLockControls: error'); }
    this.connect = function(){
      document.addEventListener('mousemove', onMouseMove, false);
      document.addEventListener('pointerlockchange', onPointerlockChange, false);
      document.addEventListener('pointerlockerror', onPointerlockError, false);
    };
    this.disconnect = function(){
      document.removeEventListener('mousemove', onMouseMove, false);
      document.removeEventListener('pointerlockchange', onPointerlockChange, false);
      document.removeEventListener('pointerlockerror', onPointerlockError, false);
    };
    this.getObject = function(){ return camera; };
    this.moveForward = function(distance){
      const v = new THREE.Vector3(); v.setFromMatrixColumn(camera.matrix, 0); v.crossVectors(camera.up, v); camera.position.addScaledVector(v, distance);
    };
    this.moveRight = function(distance){
      const v = new THREE.Vector3(); v.setFromMatrixColumn(camera.matrix, 0); camera.position.addScaledVector(v, distance);
    };
    this.lock = function(){ this.domElement.requestPointerLock(); };
    this.unlock = function(){ document.exitPointerLock(); };
    this.connect();
    this.minPolarAngle = 0; this.maxPolarAngle = Math.PI;
  }
}
</script>

<script>
/* ------------------ Fractal Worlds (Trippy Sky + Asset Upgrade) ------------------ */
(() => {
  // RNG
  class RNG {
    constructor(seed=1){
      if(typeof seed === 'string') this.seed = [...seed].reduce((a,c)=>a*131 + c.charCodeAt(0), 0);
      else this.seed = seed|0;
      this.seed = (this.seed % 2147483647) || 1;
    }
    next(){ return this.seed = (this.seed * 16807) % 2147483647; }
    f(){ return (this.next()-1)/2147483646; }
    int(min,max){ return Math.floor(min + this.f()*(max-min+1)); }
    float(min,max){ return min + this.f()*(max-min); }
  }

  // DOM
  const mandelCanvas = document.getElementById('mandel');
  const mandelCtx = mandelCanvas.getContext('2d');
  const seedInput = document.getElementById('seed');
  const platformsInput = document.getElementById('platforms');
  const startBtn = document.getElementById('startBtn');
  const regenBtn = document.getElementById('regenBtn');
  const coordEl = document.getElementById('coord');
  const zoomEl = document.getElementById('zoomLevel');
  const derivedSeedEl = document.getElementById('derivedSeed');
  const fpsEl = document.getElementById('fps');
  const weaponCanvas = document.getElementById('weaponCanvas'); const wctx = weaponCanvas.getContext('2d');

  // Mandelbrot view state
  let center = {re: -0.5, im: 0.0};
  let scale = 2.8;
  let zoomFactor = 1.0;
  let maxIterBase = 120;

  // Three.js variables
  let scene, camera, renderer, controls, clock;
  let bullets = [], enemies = [], loot = [], worldGroup = null, skyMesh = null;
  let player = { hp:100, speed:6, cooldown:0 };
  let keys = {};
  let frameCount = 0, fpsTimer = 0;

  // derive an int seed from view coords + zoom
  function deriveSeed(cx, cy, sc){
    const qx = Math.round(cx * 1e6);
    const qy = Math.round(cy * 1e6);
    const qz = Math.round((1/sc) * 1000);
    return Math.abs((qx * 73856093) ^ (qy * 19349663) ^ (qz * 83492791)) % 1000000000;
  }

  // Mandelbrot rendering
  function renderMandelbrot(viewCenter, viewScale, maxIter){
    const w = mandelCanvas.width, h = mandelCanvas.height;
    const img = mandelCtx.createImageData(w,h);
    const cx = viewCenter.re, cy = viewCenter.im;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const re = cx + (x/w - 0.5)*viewScale;
        const im = cy + (y/h - 0.5)*(viewScale * h/w);
        let zr=0, zi=0, iter=0;
        while(zr*zr + zi*zi <= 4 && iter < maxIter){
          const tmp = zr*zr - zi*zi + re;
          zi = 2*zr*zi + im;
          zr = tmp; iter++;
        }
        const idx = (y*w + x)*4;
        if(iter === maxIter){
          img.data[idx]=6; img.data[idx+1]=8; img.data[idx+2]=12; img.data[idx+3]=255;
        } else {
          const t = iter / maxIter;
          const r = Math.floor(25 + 230 * Math.sqrt(t));
          const g = Math.floor(10 + 120 * t);
          const b = Math.floor(80 + 120 * (1 - t));
          img.data[idx]=r; img.data[idx+1]=g; img.data[idx+2]=b; img.data[idx+3]=255;
        }
      }
    }
    mandelCtx.putImageData(img, 0, 0);
  }

  function updateMandelInfo(){
    coordEl.textContent = `${center.re.toFixed(6)} ${center.im>=0?'+':'-'}${Math.abs(center.im).toFixed(6)}i`;
    zoomFactor = Math.max(1, 2.8/scale);
    zoomEl.textContent = zoomFactor.toFixed(2);
    derivedSeedEl.textContent = deriveSeed(center.re, center.im, scale);
  }

  // interactive mandelbrot handlers
  let isPanning=false, panStart=null;
  mandelCanvas.addEventListener('mousedown', e=>{
    isPanning = true;
    panStart = {x:e.clientX, y:e.clientY, center: {...center}};
  });
  window.addEventListener('mouseup', ()=>{ isPanning=false; panStart=null; });
  window.addEventListener('mousemove', e=>{
    if(isPanning && panStart){
      const dx = e.clientX - panStart.x, dy = e.clientY - panStart.y;
      const w = mandelCanvas.width, h = mandelCanvas.height;
      center.re = panStart.center.re - dx/w * scale;
      center.im = panStart.center.im + dy/h * scale * (h/w);
      scheduleMandelRender(); updateMandelInfo();
    }
  });

  mandelCanvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const rect = mandelCanvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const w = mandelCanvas.width, h = mandelCanvas.height;
    const mouseRe = center.re + (mx/w - 0.5) * scale;
    const mouseIm = center.im + (my/h - 0.5) * scale * (h/w);
    const delta = e.deltaY * (e.shiftKey ? 0.0006 : 0.002);
    const factor = Math.exp(delta);
    scale *= factor;
    center.re = mouseRe + (center.re - mouseRe) * factor;
    center.im = mouseIm + (center.im - mouseIm) * factor;
    scheduleMandelRender(); updateMandelInfo();
  }, {passive:false});

  mandelCanvas.addEventListener('dblclick', e=>{
    const rect = mandelCanvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const w = mandelCanvas.width, h = mandelCanvas.height;
    const mouseRe = center.re + (mx/w - 0.5) * scale;
    const mouseIm = center.im + (my/h - 0.5) * scale * (h/w);
    const factor = 0.5;
    scale *= factor;
    center.re = mouseRe + (center.re - mouseRe) * factor;
    center.im = mouseIm + (center.im - mouseIm) * factor;
    scheduleMandelRender(); updateMandelInfo();
  });

  // click to spawn level at point
  mandelCanvas.addEventListener('click', (ev)=>{
    const rect = mandelCanvas.getBoundingClientRect();
    const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
    const w = mandelCanvas.width, h = mandelCanvas.height;
    const re = center.re + (mx/w - 0.5) * scale;
    const im = center.im + (my/h - 0.5) * scale * (h/w);
    const baseSeed = Number(seedInput.value) || 1337;
    const derived = deriveSeed(re, im, scale);
    const finalSeed = (baseSeed * 9973 + derived + Math.floor(zoomFactor*17)) % 1000000000;
    const basePlatforms = Math.max(1, Math.min(20, Number(platformsInput.value) || 6));
    const zoomMult = Math.floor(Math.max(0, Math.log2(Math.max(1, zoomFactor))));
    const platforms = Math.min(36, basePlatforms + zoomMult*3);
    generateLevel(finalSeed, platforms);
  });

  // ---------- Three initialization ----------
  function initThree(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x07060b); // keep the void vibe; sky shader will render inside scene
    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 5000);
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    controls = new PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    // lights
    const hemi = new THREE.HemisphereLight(0xbfeaff, 0x202020, 0.4); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(6, 12, 6); dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    dir.shadow.camera.left = -200; dir.shadow.camera.right = 200; dir.shadow.camera.top = 200; dir.shadow.camera.bottom = -200; scene.add(dir);

    // subtle floor so dropped loot has something to catch the eye — stays dark to preserve void
    const floorMat = new THREE.MeshStandardMaterial({color:0x222238, roughness:0.95});
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), floorMat); floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

    createVisibleWeapon();
    clock = new THREE.Clock();
  }

  // visible weapon
  let weaponGroup;
  function createVisibleWeapon(){
    weaponGroup = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.36,0.18,1.06), new THREE.MeshStandardMaterial({color:0x202020})); body.position.set(0.48,-0.33,-0.58); weaponGroup.add(body);
    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,0.86,8), new THREE.MeshStandardMaterial({color:0x00ffcc, metalness:0.8, roughness:0.2})); barrel.rotation.z=Math.PI/2; barrel.position.set(0.95,-0.33,-0.58); weaponGroup.add(barrel);
    camera.add(weaponGroup); weaponGroup.position.set(0,-0.24,-0.45);
  }

  // ----------- Sky shader (per-world randomized) -----------
  const skyVertex = `
    varying vec3 vPos;
    void main(){
      vPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `;
  const skyFragment = `
    precision highp float;
    varying vec3 vPos;
    uniform float uTime;
    uniform vec3 uA;
    uniform vec3 uB;
    uniform vec3 uC;
    uniform vec3 uD;
    uniform float uSpeed;
    // IQ palette
    vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d){
      return a + b * cos(6.28318*(c*t + d));
    }
    void main(){
      // radial + noise-like wobble using trig; vPos is inside a unit-ish sphere
      vec3 p = normalize(vPos);
      float t = uTime * uSpeed;
      float v = sin(3.0*p.x + 2.0*p.y + t) + cos(4.0*p.z - 1.5*p.x + t*0.6);
      v += sin(6.0*p.y + t*1.3)*0.5;
      v = v*0.5 + 0.5;
      vec3 col = palette(v, uA, uB, uC, uD);
      // slight vignette to keep center readable
      float vig = smoothstep(1.2, 0.2, length(p.xy));
      col *= mix(0.4, 1.0, vig);
      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function createSky(rng){
    // palette params per world
    const A = new THREE.Color().setHSL(rng.f(), 0.3 + rng.f()*0.2, 0.1 + rng.f()*0.2);
    const B = new THREE.Color().setHSL(rng.f(), 0.5 + rng.f()*0.4, 0.3 + rng.f()*0.3);
    const C = new THREE.Vector3(rng.float(0.2,0.8), rng.float(0.2,0.8), rng.float(0.2,0.8));
    const D = new THREE.Vector3(rng.f(), rng.f(), rng.f());
    const speed = rng.float(0.05, 0.25);

    const uniforms = {
      uTime: { value: 0 },
      uA: { value: new THREE.Vector3(A.r, A.g, A.b) },
      uB: { value: new THREE.Vector3(B.r, B.g, B.b) },
      uC: { value: C },
      uD: { value: D },
      uSpeed: { value: speed }
    };

    const mat = new THREE.ShaderMaterial({
      uniforms,
      vertexShader: skyVertex,
      fragmentShader: skyFragment,
      side: THREE.BackSide,
      depthWrite: false
    });
    const geo = new THREE.SphereGeometry(1800, 32, 32);
    const mesh = new THREE.Mesh(geo, mat);
    return { mesh, uniforms };
  }

  // ---------- Level generation ----------
  function generateLevel(seed, platformsCount){
    // clear previous world
    if(worldGroup){
      try{ scene.remove(worldGroup); worldGroup.traverse(c=>{ if(c.geometry) c.geometry.dispose(); if(c.material) { if(c.material.map) c.material.map.dispose(); c.material.dispose(); } }); }catch(e){}
    }
    if(skyMesh){ try{ scene.remove(skyMesh); if(skyMesh.geometry) skyMesh.geometry.dispose(); if(skyMesh.material) skyMesh.material.dispose(); }catch(e){}
      skyMesh = null; }

    worldGroup = new THREE.Group();
    scene.add(worldGroup);
    enemies.forEach(e=> scene.remove(e)); enemies = [];
    bullets.forEach(b=> scene.remove(b)); bullets = [];
    loot.forEach(l=> scene.remove(l)); loot=[];

    const rng = new RNG(seed);

    // fog color lightly tied to seed (still low density to preserve void)
    const baseHue = rng.f();
    scene.fog = new THREE.FogExp2(new THREE.Color().setHSL(baseHue, 0.5, 0.04).getHex(), 0.006 + rng.f()*0.02);

    // create sky dome (per-world randomized shader)
    const { mesh: sky, uniforms } = createSky(rng);
    skyMesh = sky;
    scene.add(skyMesh);

    // central core — rotating rings
    const core = new THREE.Group();
    const ringCount = Math.max(3, Math.min(12, Math.floor(platformsCount/2)));
    for(let i=0;i<ringCount;i++){
      const radius = 6 + i*1.5 + rng.float(-0.6,0.6);
      const tube = 0.6 + rng.f()*0.6;
      const segs = 12;
      const geo = new THREE.TorusGeometry(radius, tube, 4, segs);
      const mat = new THREE.MeshStandardMaterial({emissive: new THREE.Color().setHSL((baseHue + i*0.08)%1, 0.9, 0.25), color: new THREE.Color().setHSL((baseHue + i*0.08)%1,0.4,0.2), roughness: 0.35, metalness:0.6});
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = rng.f()*Math.PI;
      mesh.rotation.y = rng.f()*Math.PI;
      mesh.position.set(rng.float(-2,2), rng.float(-1,1), rng.float(-2,2));
      mesh.castShadow = false; mesh.receiveShadow = true;
      core.add(mesh);
    }
    worldGroup.add(core);

    // floating platforms
    const platforms = [];
    for(let i=0;i<platformsCount;i++){
      const angle = rng.f() * Math.PI * 2;
      const dist = 6 + i * rng.float(2.5, 5) + rng.float(-1.2,1.2);
      const x = Math.cos(angle) * dist;
      const z = Math.sin(angle) * dist;
      const y = rng.float(-1.5, 4) + (i%2===0 ? 1 : -0.5);
      const size = rng.float(2.2, 6.0) * (1 + Math.sin(i)*0.15);
      const geom = new THREE.CylinderGeometry(size, size*0.6, 0.6, 14);
      const mat = new THREE.MeshStandardMaterial({color: new THREE.Color().setHSL((baseHue + rng.f()*0.3) % 1, 0.4, 0.25), roughness:0.6, metalness:0.2, emissive: new THREE.Color().setHSL((baseHue + rng.f()*0.4)%1, 0.9, 0.06)});
      const platform = new THREE.Mesh(geom, mat);
      platform.position.set(x,y,z);
      platform.rotation.y = rng.f()*Math.PI;
      platform.castShadow = true; platform.receiveShadow = true;
      worldGroup.add(platform);
      platforms.push(platform);

      // extra assets per platform — arches, shards, hoops
      spawnAssetCluster(rng, baseHue, platform.position, size*0.6);

      // small pillars
      const pillars = rng.int(0,3);
      for(let p=0;p<pillars;p++){
        const h = rng.float(0.6,3.2);
        const pg = new THREE.CylinderGeometry(0.12, 0.12, h, 6);
        const pm = new THREE.MeshStandardMaterial({color: new THREE.Color().setHSL((baseHue + rng.f()*0.5)%1, 0.6, 0.18), roughness:0.7});
        const pillar = new THREE.Mesh(pg, pm);
        pillar.position.set(x + rng.float(-size/3, size/3), y + h/2 + 0.1, z + rng.float(-size/3, size/3));
        pillar.castShadow = true; pillar.receiveShadow = true;
        worldGroup.add(pillar);
      }

      // enemies
      if(rng.f() < 0.9){
        const ecount = rng.int(1,3);
        for(let ei=0; ei<ecount; ei++){
          const enemy = createWorldEnemy(rng, baseHue);
          enemy.position.set(x + rng.float(-size/3, size/3), y + 0.6, z + rng.float(-size/3, size/3));
          scene.add(enemy); enemies.push(enemy);
        }
      }

      // loot
      if(rng.f() < 0.5){
        const l = createLoot(rng);
        l.position.set(x + rng.float(-size/4, size/4), y + 0.4, z + rng.float(-size/4, size/4));
        scene.add(l); loot.push(l);
      }
    }

    // particles
    const particlesGeom = new THREE.BufferGeometry();
    const pCount = Math.min(900, 160 + platformsCount * 50);
    const posArr = new Float32Array(pCount*3);
    for(let i=0;i<pCount;i++){
      const a = rng.f() * Math.PI * 2;
      const rdist = rng.float(2, platformsCount*3 + 6);
      const px = Math.cos(a)*rdist + rng.float(-2,2);
      const pz = Math.sin(a)*rdist + rng.float(-2,2);
      const py = rng.float(-4,6);
      posArr[i*3+0]=px; posArr[i*3+1]=py; posArr[i*3+2]=pz;
    }
    particlesGeom.setAttribute('position', new THREE.BufferAttribute(posArr,3));
    const points = new THREE.Points(particlesGeom, new THREE.PointsMaterial({size: 0.08, color: new THREE.Color().setHSL((baseHue+0.2)%1, 0.7, 0.6), transparent:true, opacity:0.8}));
    worldGroup.add(points);

    // boss
    const boss = createTrippyBoss(rng, baseHue, Math.max(1, Math.floor(platformsCount/6)));
    boss.position.set(0, 6 + rng.float(2,6) + platformsCount*0.2, 0);
    scene.add(boss); enemies.push(boss);

    // spawn player
    let spawnPos = platforms.length ? platforms[0].position.clone() : new THREE.Vector3(0,2,6);
    spawnPos.y += 1.2;
    controls.getObject().position.copy(spawnPos);
    camera.position.copy(spawnPos);

    worldGroup.userData = {seed, rng, baseHue, core, platforms, particles:points, boss, skyUniforms: uniforms};
  }

  // ----- Asset clusters -----
  function spawnAssetCluster(rng, baseHue, origin, radius){
    const group = new THREE.Group();
    const count = rng.int(1,5);
    for(let i=0;i<count;i++){
      const t = rng.f()*Math.PI*2;
      const r = rng.float(radius*0.2, radius*0.9);
      const pos = new THREE.Vector3(origin.x + Math.cos(t)*r, origin.y + rng.float(0.2,1.6), origin.z + Math.sin(t)*r);
      const type = rng.int(0,3);
      let mesh;
      if(type===0){ // arch
        const g = new THREE.TorusGeometry(rng.float(0.6,1.4), rng.float(0.06,0.18), 6, 24, Math.PI);
        const m = new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL((baseHue + rng.f()*0.4)%1,0.6,0.35), metalness:0.5, roughness:0.3, emissive:new THREE.Color().setHSL((baseHue + rng.f()*0.4)%1,0.8,0.06)});
        mesh = new THREE.Mesh(g,m);
        mesh.rotation.set(-Math.PI/2, rng.f()*Math.PI, 0);
      } else if(type===1){ // shard
        const g = new THREE.ConeGeometry(rng.float(0.08,0.18), rng.float(0.6,1.6), 6);
        const m = new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL((baseHue + rng.f()*0.5)%1,0.7,0.5), metalness:0.2, roughness:0.7});
        mesh = new THREE.Mesh(g,m);
        mesh.rotation.set(rng.f()*Math.PI, rng.f()*Math.PI, rng.f()*Math.PI);
      } else if(type===2){ // hoop
        const g = new THREE.TorusKnotGeometry(rng.float(0.2,0.5), rng.float(0.04,0.09), 40, 8);
        const m = new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL((baseHue + rng.f()*0.5)%1,0.8,0.45), metalness:0.7, roughness:0.2, emissive: new THREE.Color().setHSL((baseHue + rng.f()*0.3)%1, 0.9, 0.08)});
        mesh = new THREE.Mesh(g,m);
      } else { // ring stack
        const g = new THREE.TorusGeometry(rng.float(0.3,0.7), rng.float(0.04,0.1), 6, 18);
        const m = new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL((baseHue + rng.f()*0.3)%1,0.5,0.3), metalness:0.4, roughness:0.4});
        mesh = new THREE.Mesh(g,m);
        mesh.rotation.x = rng.f()*Math.PI;
      }
      mesh.position.copy(pos);
      mesh.castShadow = true; mesh.receiveShadow = true;
      group.add(mesh);
    }
    worldGroup.add(group);
  }

  // ----- Enemies -----
  function createWorldEnemy(rng, baseHue){
    const variant = rng.int(0,4);
    let geom;
    if(variant===0) geom = new THREE.TetrahedronGeometry(0.45 + rng.f()*0.6);
    else if(variant===1) geom = new THREE.IcosahedronGeometry(0.5 + rng.f()*0.5, 0);
    else if(variant===2) geom = new THREE.DodecahedronGeometry(0.5 + rng.f()*0.5, 0);
    else if(variant===3) geom = new THREE.BoxGeometry(0.5 + rng.f()*0.4, 0.5 + rng.f()*0.4, 0.5 + rng.f()*0.4);
    else geom = new THREE.TorusKnotGeometry(0.25 + rng.f()*0.25, 0.08, 32, 6);

    const hue = (baseHue + rng.f()*0.5) % 1;
    const mat = new THREE.MeshStandardMaterial({
      color: new THREE.Color().setHSL(hue, 0.9, 0.5),
      emissive: new THREE.Color().setHSL(hue, 0.9, 0.15),
      roughness: 0.3 + rng.f()*0.4,
      metalness: 0.4 + rng.f()*0.5
    });
    const m = new THREE.Mesh(geom, mat);
    m.castShadow = true; m.receiveShadow = false;
    // randomize stats per world
    m.userData = {
      hp: 8 + Math.round(rng.f()*16),
      speed: 0.5 + rng.f()*2.0,
      phase: rng.f()*Math.PI*2
    };
    return m;
  }

  function createLoot(rng){
    const g = new THREE.BoxGeometry(0.5,0.5,0.5);
    const mat = new THREE.MeshStandardMaterial({color: new THREE.Color().setHSL(rng.f(), 0.8, 0.6), emissive: new THREE.Color().setHSL(rng.f(), 0.8, 0.12)});
    const m = new THREE.Mesh(g, mat);
    m.castShadow = true; m.userData = {value: rng.int(5,30)};
    return m;
  }

  function createTrippyBoss(rng, baseHue, phaseCount){
    const bossGroup = new THREE.Group();
    const size = 2.2 + phaseCount*0.8;
    const oct = new THREE.Mesh(new THREE.OctahedronGeometry(size, 0), new THREE.MeshStandardMaterial({color: new THREE.Color().setHSL((baseHue+0.5)%1,0.85,0.45), emissive: new THREE.Color().setHSL((baseHue+0.5)%1, 0.9, 0.12), metalness:0.3, roughness:0.2}));
    oct.castShadow = true; bossGroup.add(oct);
    const ring = new THREE.Mesh(new THREE.TorusGeometry(size*1.6, 0.25, 6, 24), new THREE.MeshStandardMaterial({color: new THREE.Color().setHSL((baseHue+0.9)%1,0.9,0.28), emissive: new THREE.Color().setHSL((baseHue+0.9)%1,0.9,0.08), metalness:0.6, roughness:0.1}));
    bossGroup.add(ring);
    bossGroup.userData = {hp: 120 + phaseCount*90, speed: 0.2 + phaseCount*0.08, seed: rng.seed, attackTimer: 0, phase: 0, baseHue, boss:true};
    bossGroup.tick = (dt) => {
      oct.rotation.x += dt*0.2; oct.rotation.y += dt*0.18;
      ring.rotation.z += dt*0.25;
      const hueShift = (Date.now() * 0.00008 + rng.f()) % 1;
      oct.material.color.setHSL((bossGroup.userData.baseHue + hueShift)%1, 0.7, 0.45);
      ring.material.color.setHSL((bossGroup.userData.baseHue + hueShift + 0.25)%1, 0.9, 0.28);
      bossGroup.userData.attackTimer -= dt;
      if(bossGroup.userData.attackTimer <= 0){
        bossGroup.userData.attackTimer = 2.0 + rng.f()*2.5;
        spawnBossPulse(bossGroup, rng);
      }
    };
    return bossGroup;
  }

  function spawnBossPulse(boss, rng){
    const origin = new THREE.Vector3().setFromMatrixPosition(boss.matrixWorld);
    const shotCount = 8 + rng.int(0,8);
    for(let i=0;i<shotCount;i++){
      const theta = rng.f() * Math.PI * 2;
      const phi = rng.f() * Math.PI * 0.6 - 0.2;
      const dir = new THREE.Vector3(Math.cos(theta)*Math.cos(phi), Math.sin(phi), Math.sin(theta)*Math.cos(phi)).normalize();
      spawnEnemyProjectile(origin, dir, 14 + rng.f()*8, 6 + rng.int(-1,4), 0xff33aa);
    }
    const playerPos = controls.getObject().position.clone();
    const aim = new THREE.Vector3().subVectors(playerPos, origin).normalize();
    spawnEnemyProjectile(origin, aim, 25, 10, 0xffdd55);
  }

  function spawnEnemyProjectile(position, dir, speed, damage, colorHex){
    const g = new THREE.SphereGeometry(0.12, 6, 6);
    const m = new THREE.Mesh(g, new THREE.MeshStandardMaterial({color: colorHex, emissive: colorHex, metalness: 0.6}));
    m.position.copy(position);
    m.userData = {vel: dir.clone().multiplyScalar(speed), life: 6, damage, projectile:true};
    scene.add(m);
    enemies.push(m);
  }

  // ---------- Shooting & collisions ----------
  function shoot(){
    if(player.cooldown > 0) return;
    player.cooldown = 0.12;
    const geo = new THREE.SphereGeometry(0.08, 8, 8);
    const mat = new THREE.MeshStandardMaterial({color:0xaaff77, emissive:0x66ff88, metalness:0.6});
    const bullet = new THREE.Mesh(geo, mat); bullet.castShadow = true;
    bullet.position.copy(camera.position);
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    bullet.userData = {vel: dir.multiplyScalar(80), life: 3.5, damage: 10, owner: 'player'};
    scene.add(bullet); bullets.push(bullet);
  }

  function updateBullets(dt){
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.position.addScaledVector(b.userData.vel, dt);
      b.userData.life -= dt;
      for(let j=enemies.length-1;j>=0;j--){
        const e = enemies[j];
        if(e.userData && e.userData.projectile) continue;
        if(!e.userData || (!e.userData.hp && !e.userData.boss)) continue;
        const dist = (e.position ? e.position.distanceTo(b.position) : new THREE.Vector3().setFromMatrixPosition(e.matrixWorld).distanceTo(b.position));
        if(dist < 0.9){
          if(e.userData.boss){
            e.userData.hp -= b.userData.damage;
            e.scale.setScalar(1 + Math.random()*0.05);
            if(e.userData.hp <= 0){ if(e.parent) e.parent.remove(e); scene.remove(e); }
          } else {
            e.userData.hp -= b.userData.damage;
            if(e.userData.hp <= 0){ scene.remove(e); enemies.splice(j,1); }
          }
          b.userData.life = 0; break;
        }
      }
      if(b.userData.life <= 0){ scene.remove(b); bullets.splice(i,1); }
    }
  }

  function updateEnemies(dt){
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      if(e.userData && e.userData.projectile){
        e.position.addScaledVector(e.userData.vel, dt);
        e.userData.life -= dt;
        if(e.userData.life <= 0){ scene.remove(e); enemies.splice(i,1); continue; }
        if(e.position.distanceTo(camera.position) < 1.2){ player.hp -= e.userData.damage; scene.remove(e); enemies.splice(i,1); continue; }
        continue;
      }
      if(e.userData && !e.userData.boss){
        const dir = new THREE.Vector3().subVectors(camera.position, e.position).setY(0);
        const dist = dir.length();
        const t = Date.now() * 0.001 + (e.userData.phase || 0);
        e.position.y += Math.sin(t*1.2) * dt * 0.6;
        if(dist > 1.6){ dir.normalize(); e.position.addScaledVector(dir, dt * e.userData.speed); }
        else { player.hp -= dt * 6; }
        e.rotation.x += dt*0.6; e.rotation.y += dt*0.4; // spin for style
      } else if(e.userData && e.userData.boss){ if(e.tick) e.tick(dt); }
    }
  }

  function updateLoot(){
    for(let i=loot.length-1;i>=0;i--){
      const l = loot[i];
      if(camera.position.distanceTo(l.position) < 1.2){ player.hp = Math.min(200, player.hp + (l.userData.value || 10)); scene.remove(l); loot.splice(i,1); }
    }
  }

  // ---------- Input wiring ----------
  startBtn.addEventListener('click', ()=>{ controls.lock(); });
  regenBtn.addEventListener('click', ()=>{
    const p = pickPoint(Number(seedInput.value)||1337);
    const derived = deriveSeed(p.re, p.im, scale);
    const finalSeed = (Number(seedInput.value)||1337) * 9973 + derived;
    const platforms = Math.max(1, Math.min(36, Number(platformsInput.value) || 6));
    generateLevel(finalSeed, platforms);
  });

  window.addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true; if(e.key===' ') e.preventDefault(); });
  window.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });
  window.addEventListener('mousedown', (e)=>{ if(controls.isLocked) shoot(); });

  function shoot(){ shootWeapon(); }
  function shootWeapon(){ shoot(); }

  // ---------- Mandelbrot helpers ----------
  let mandelScheduled = false;
  function scheduleMandelRender(){
    if(mandelScheduled) return;
    mandelScheduled = true;
    requestAnimationFrame(()=>{
      mandelScheduled = false;
      const zoom = Math.max(1, 2.8/scale);
      const maxIter = Math.floor(maxIterBase + Math.log2(zoom) * 80);
      renderMandelbrot(center, scale, Math.max(80, Math.min(2000, maxIter)));
      updateMandelInfo();
    });
  }

  function pickPoint(seed){
    const w = mandelCanvas.width, h = mandelCanvas.height;
    const r = new RNG(seed);
    let best = null, bestIt = -1;
    for(let t=0;t<300;t++){
      const x = r.int(0,w-1), y = r.int(0,h-1);
      const re = center.re + (x/w - 0.5)*scale;
      const im = center.im + (y/h - 0.5)*scale * (h/w);
      let zr=0, zi=0, iter=0, maxIter=200;
      while(zr*zr + zi*zi <= 4 && iter < maxIter){
        const tmp = zr*zr - zi*zi + re; zi = 2*zr*zi + im; zr = tmp; iter++;
      }
      if(iter > bestIt){ bestIt = iter; best = {re, im}; }
    }
    return best || {re:center.re, im:center.im};
  }

  // ---------- animation / main loop ----------
  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(0.06, clock.getDelta());

    // movement
    if(controls.isLocked){
      const speed = player.speed * dt;
      if(keys['w']) controls.moveForward(speed);
      if(keys['s']) controls.moveForward(-speed);
      if(keys['a']) controls.moveRight(-speed);
      if(keys['d']) controls.moveRight(speed);
    }

    // updates
    updateBullets(dt);
    updateEnemies(dt);
    updateLoot();
    if(player.cooldown > 0) player.cooldown -= dt;

    // animate world features
    if(worldGroup && worldGroup.userData){
      const ud = worldGroup.userData, rng = ud.rng;
      if(ud.core){
        ud.core.rotation.y += dt * 0.08;
        ud.core.traverse(m=>{ if(m.material && m.material.emissive){ const t = (Date.now()*0.0002 + (rng.f()*10))%1; try { m.material.emissive.setHSL((ud.baseHue + t)%1, 0.8, 0.06); } catch(e) {} } });
      }
      if(ud.particles){ ud.particles.rotation.y += dt * 0.02; }
      if(ud.skyUniforms){ ud.skyUniforms.uTime.value += dt; }
    }

    // HUD / FPS
    frameCount++; fpsTimer += dt;
    if(fpsTimer >= 1){ fpsEl.textContent = 'FPS: ' + frameCount; frameCount = 0; fpsTimer = 0; }

    drawWeaponHUD();
    renderer.render(scene, camera);
  }

  function drawWeaponHUD(){
    wctx.clearRect(0,0,weaponCanvas.width,weaponCanvas.height);
    wctx.fillStyle = '#ddd'; wctx.font = '13px monospace';
    wctx.fillText('HP: ' + Math.max(0, Math.round(player.hp)) + '   Seed: ' + (deriveSeed(center.re, center.im, scale)), 8, 18);
  }

  // ---------- initial boot ----------
  function initAll(){
    initThree();
    scheduleMandelRender();
    updateMandelInfo();
    const p = pickPoint(Number(seedInput.value)||1337);
    const derived = deriveSeed(p.re, p.im, scale);
    const finalSeed = (Number(seedInput.value)||1337) * 9973 + derived;
    const platforms = Math.max(3, Number(platformsInput.value)||6);
    generateLevel(finalSeed, platforms);
    clock = new THREE.Clock();
    animate();
  }

  initAll();

  window._fractalWorld = { generateLevel, deriveSeed, center, scale, scene, camera };
})();
</script>
</body>
</html>
<Updated code here with the following changes applied>
