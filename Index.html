<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fractal Tunnel FPS — Neon LowPoly (Desktop)</title>
<style>
  :root{
    --panel-bg: rgba(6,6,12,0.6);
    --accent: #66f0ff;
    --accent-2: #ff66f0;
    --text: #eaf6ff;
  }
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,Segoe UI,Roboto,system-ui,Arial;}
  #container{width:100%;height:100%;position:relative;touch-action:none}
  canvas{display:block}
  #ui {
    position: absolute; left: 12px; top: 12px; z-index: 40;
    background: var(--panel-bg); padding: 10px; border-radius: 10px;
    color: var(--text); backdrop-filter: blur(6px);
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    min-width: 320px;
  }
  #ui h1{margin:0 0 8px 0;font-size:16px;color:var(--accent)}
  #ui .row{display:flex;gap:8px;align-items:center;margin-bottom:6px}
  input[type="number"]{width:120px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:#081018;color:var(--text)}
  button{padding:8px 10px;border-radius:8px;border:0;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#041018;font-weight:700;cursor:pointer}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);font-weight:600}
  #hud {
    position:absolute; right:12px; top:12px; z-index:40;
    background: rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px; color:var(--text);
    display:flex; gap:12px; align-items:center; font-family:monospace;
  }
  #infoBar{position:absolute;left:12px;bottom:12px;color:rgba(230,250,255,0.9);z-index:40;font-size:13px;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px}
  .small{font-size:12px;color:#9fb6c7}
  /* pointerlock hint */
  #hint{position:absolute;left:50%;transform:translateX(-50%);bottom:18vh;color:rgba(200,220,255,0.9);font-size:13px;z-index:40;padding:8px 12px;background:rgba(0,0,0,0.25);border-radius:8px}
</style>
</head>
<body>
<div id="container"></div>

<div id="ui">
  <h1>Fractal Tunnel FPS (neon)</h1>
  <div class="row">
    <label>Seed <input id="seedInput" type="number" placeholder="12345" /></label>
    <label>Depth <input id="depthInput" type="number" min="1" max="10" value="2" /></label>
    <button id="enterBtn">Enter Portal</button>
  </div>
  <div class="row">
    <button class="secondary" id="prevBtn">&larr; Prev Room</button>
    <button class="secondary" id="nextBtn">Next Room &rarr;</button>
    <button class="secondary" id="teleportBtn">Teleport to Tunnel Start</button>
  </div>
  <div class="small">Tip: Click the screen to lock pointer and look around. WASD to move. Click to shoot.</div>
</div>

<div id="hud">
  <div id="weaponName">Weapon: —</div>
  <div id="health">HP: 100</div>
  <div id="monCount">Enemies: 0</div>
</div>

<div id="infoBar">Seed: <span id="currentSeed">—</span> • Room Index: <span id="roomIndex">—</span></div>
<div id="hint">Click to lock pointer — move with WASD</div>

<!-- Three.js from CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.min.js"></script>
<script>
/* ====================
   Chunk 1 — Scene init
   ==================== */

const container = document.getElementById('container');
let renderer, scene, camera, clock, controls;

function initRenderer(){
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace || null;
  container.appendChild(renderer.domElement);
  window.addEventListener('resize', onResize);
}

function onResize(){
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function initScene(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.05, 2000);
  camera.position.set(0,1.6, 6); // eye height
  clock = new THREE.Clock();

  // lighting — neon ambient + directional
  const amb = new THREE.HemisphereLight(0x88ddff, 0x220033, 0.6);
  scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(5,10,7);
  scene.add(dir);

  // FRAMER: simple low-poly floor tunnel placeholder (we'll replace with shader)
  const tubeGeom = new THREE.CylinderGeometry(6, 6, 120, 32, 1, true);
  tubeGeom.rotateX(Math.PI/2);
  tubeGeom.translate(0, 0, -60); // extend forward from origin
  // simple neon material
  const tubeMat = new THREE.MeshStandardMaterial({
    color: 0x001122,
    emissive: 0x112233,
    side: THREE.BackSide,
    metalness: 0.1,
    roughness: 0.6,
    transparent: true,
    opacity: 0.95
  });
  const tunnelMesh = new THREE.Mesh(tubeGeom, tubeMat);
  tunnelMesh.name = "tunnel";
  scene.add(tunnelMesh);

  // a few neon rings to show movement
  const ringMat = new THREE.MeshBasicMaterial({color:0x44eaff, transparent:true, opacity:0.12});
  for(let i=0;i<30;i++){
    const r = new THREE.RingGeometry(4.8 - (i*0.02), 5.0 - (i*0.02), 64);
    const m = new THREE.Mesh(r, ringMat);
    m.rotateX(-Math.PI/2);
    m.position.z = -i*3 - 5;
    m.position.y = 0;
    scene.add(m);
  }

  // placeholder player weapon viewmodel (will be replaced with low-poly mesh)
  const vmGeo = new THREE.BoxGeometry(0.14, 0.08, 0.6);
  const vmMat = new THREE.MeshStandardMaterial({color:0xffffff, emissive:0x66f0ff, metalness:0.5, roughness:0.2});
  const viewModel = new THREE.Mesh(vmGeo, vmMat);
  viewModel.position.set(0.3,-0.25,-0.8);
  viewModel.name = "viewmodel";
  camera.add(viewModel);
  scene.add(camera);

  // simple ground marker
  const markerGeo = new THREE.SphereGeometry(0.08,8,8);
  const markerMat = new THREE.MeshStandardMaterial({color:0xff66ff, emissive:0x330022});
  const marker = new THREE.Mesh(markerGeo, markerMat);
  marker.position.set(0,0,-2);
  marker.name="marker";
  scene.add(marker);
}

function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  // update later (player movement, monsters)
  renderer.render(scene, camera);
}

// attach pointerlock controls (simple wrapper)
function enablePointerLockHint(){
  const hint = document.getElementById('hint');
  const canvasEl = renderer.domElement;
  canvasEl.addEventListener('click', ()=> {
    canvasEl.requestPointerLock?.();
    hint.style.display = 'none';
  });
  document.addEventListener('pointerlockchange', ()=> {
    if(document.pointerLockElement === canvasEl) {
      hint.style.display = 'none';
    } else {
      hint.style.display = '';
    }
  });
}

/* UI wiring */
const seedInput = document.getElementById('seedInput');
const depthInput = document.getElementById('depthInput');
const enterBtn = document.getElementById('enterBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const teleportBtn = document.getElementById('teleportBtn');
const currentSeedEl = document.getElementById('currentSeed');
const roomIndexEl = document.getElementById('roomIndex');

enterBtn.addEventListener('click', ()=> {
  const s = parseInt(seedInput.value) || Math.floor(Math.random()*999999);
  const d = parseInt(depthInput.value) || 1;
  enterPortal(s, d);
});
prevBtn.addEventListener('click', ()=> jumpRoom(-1));
nextBtn.addEventListener('click', ()=> jumpRoom(1));
teleportBtn.addEventListener('click', ()=> teleportToStart());

/* Placeholder stubs — filled in later chunks */
let currentRoomIndex = 0;
function enterPortal(seed, depth){
  console.log("enterPortal", seed, depth);
  currentSeedEl.textContent = seed;
  // map seeds to room indices on tunnel
  currentRoomIndex = 0;
  roomIndexEl.textContent = currentRoomIndex;
  // spawn room & enemies — implemented in Chunk 3/4
}
function jumpRoom(delta){
  currentRoomIndex += delta;
  roomIndexEl.textContent = currentRoomIndex;
  // compute seed based on index and navigate — later chunks
}
function teleportToStart(){
  camera.position.set(0,1.6,6);
  camera.rotation.set(0,0,0);
}

/* Initialize everything */
initRenderer();
initScene();
enablePointerLockHint();
animate();

</script>
</body>
/* =========================
   Chunk 2 — Raymarch Tunnel
   ========================= */

// --- Tunnel shader (screen-space raymarch) ---

const tunnelVS = `#version 300 es
precision highp float;
in vec2 aPos;
out vec2 vUv;
void main(){
  vUv = aPos * 0.5 + 0.5;
  gl_Position = vec4(aPos, 0.0, 1.0);
}
`;

const tunnelFS = `#version 300 es
precision highp float;
in vec2 vUv;
out vec4 fragColor;

uniform float uTime;
uniform vec2 uRes;
uniform vec3 uCamPos;
uniform mat4 uInvProj;
uniform mat4 uInvView;
uniform float uSeed;
uniform int uDepth;
uniform int uSteps;
uniform float uTunnelRadius;
uniform float uSegmentLen;

// hash / noise
float hash(float n){ return fract(sin(n)*43758.5453123); }
float noise(vec3 x){
  vec3 p = floor(x);
  vec3 f = fract(x);
  f = f*f*(3.0-2.0*f);
  float n = p.x + p.y*57.0 + 113.0*p.z;
  float res = mix(mix(mix(hash(n+0.0), hash(n+1.0), f.x),
                      mix(hash(n+57.0), hash(n+58.0), f.x), f.y),
                  mix(mix(hash(n+113.0), hash(n+114.0), f.x),
                      mix(hash(n+170.0), hash(n+171.0), f.x), f.y), f.z);
  return res;
}

// warp & fractal-like detail
float fbm(vec3 p){
  float v=0.0; float a=0.5;
  for(int i=0;i<4;i++){
    v += a*noise(p);
    p *= 2.0;
    a *= 0.5;
  }
  return v;
}

// tunnel SDF: base cylinder + ripples + rooms along z
float tunnelSDF(vec3 p){
  // make tunnel along -Z axis (camera looks toward -Z)
  // radius modulation by seed & depth
  float baseR = uTunnelRadius * (1.0 + 0.08*float(uDepth));
  // ripple from shader noise
  float ripple = 0.2 * fbm(vec3(p.x*0.6, p.y*0.6, p.z*0.12 + uSeed*0.001 + uTime*0.02));
  // rooms pattern: periodic expansions at segment intervals, seeded variation
  float seg = uSegmentLen;
  float rz = mod(p.z + seg*1000.0, seg) - seg*0.5; // centered segment coordinate
  float roomPulse = exp(-abs(rz)*0.6) * (0.8 + 0.4*sin(uSeed*0.001 + floor((p.z+1000.0)/seg)*0.5));
  float r = baseR * (1.0 + ripple + roomPulse);
  float d = length(p.xy) - r;
  // add small protrusions for fractal feel
  float detail = fbm(p*1.7 + vec3(0.0,0.0,uTime*0.1)) * 0.15;
  return d - detail;
}

// estimate normal
vec3 estimateNormal(vec3 p){
  float e = 0.002;
  return normalize(vec3(
    tunnelSDF(p + vec3(e,0,0)) - tunnelSDF(p - vec3(e,0,0)),
    tunnelSDF(p + vec3(0,e,0)) - tunnelSDF(p - vec3(0,e,0)),
    tunnelSDF(p + vec3(0,0,e)) - tunnelSDF(p - vec3(0,0,e))
  ));
}

// lighting (neon rim + center)
vec3 shade(vec3 p, vec3 n, vec3 rd){
  // neon rim based on normal vs view
  float rim = pow(1.0 - max(dot(n, -rd), 0.0), 2.4);
  vec3 colBase = vec3(0.04, 0.02, 0.08); // dark base
  // color variations by z and seed
  float t = fract(uSeed*0.00012 + p.z*0.02 + uTime*0.03);
  vec3 neon = mix(vec3(0.3,0.9,1.0), vec3(1.0,0.4,0.9), t);
  vec3 glow = neon * rim * 2.5;
  // center light along axis
  float center = exp(-length(p.xy)*0.5);
  vec3 centerColor = neon * center * 0.6;
  // subtle banding by room index
  float band = smoothstep(0.2, 0.8, abs(sin(p.z * 0.5 + uSeed*0.0007)));
  vec3 bandColor = mix(vec3(0.05,0.02,0.1), neon*0.5, band*0.8);
  return clamp(colBase + glow + centerColor + bandColor*0.6, 0.0, 1.8);
}

void main(){
  // reconstruct ray in world space from inv proj and inv view
  vec2 uv = (vUv * 2.0 - 1.0);
  vec4 clip = vec4(uv, -1.0, 1.0);
  vec4 viewPos = uInvProj * clip;
  viewPos /= viewPos.w;
  vec4 worldPos = uInvView * viewPos;
  vec3 ro = uCamPos;
  vec3 rd = normalize(worldPos.xyz - ro);

  // march along ray
  float t = 0.0;
  float dist = -1.0;
  vec3 pHit = vec3(0.0);
  for(int i=0;i<200;i++){
    if(i >= uSteps) break;
    vec3 p = ro + rd * t;
    // push sample a bit forward so camera inside tunnel sees inner walls quickly
    float d = tunnelSDF(p);
    if(d < 0.001){
      dist = t; pHit = p; break;
    }
    t += d;
    if(t > 150.0) break;
  }

  if(dist > 0.0){
    vec3 n = estimateNormal(pHit);
    vec3 color = shade(pHit, n, rd);
    // add post fx: vignette and slight chroma shift
    float vign = smoothstep(1.6, 0.0, length(vUv - 0.5));
    color *= mix(0.8, 1.0, vign);
    // add small grain
    float g = (hash(uTime + pHit.z) - 0.5)*0.02;
    color += g;
    fragColor = vec4(color, 1.0);
  } else {
    // fallback background gradient
    vec3 bg = vec3(0.01,0.02,0.03) + 0.12 * vec3(0.2 + 0.8 * sin(uTime*0.3 + uSeed*0.0004 + vUv.x*6.0),
                                                 0.2 + 0.8 * cos(uTime*0.4 + vUv.y*5.0),
                                                 0.3 + 0.7 * sin(uTime*0.2 + vUv.x*4.0));
    fragColor = vec4(bg, 1.0);
  }
}
`;

// Build shader material and full-screen quad
const tunnelUniforms = {
  uTime: {value: 0.0},
  uRes: {value: new THREE.Vector2(window.innerWidth, window.innerHeight)},
  uCamPos: {value: new THREE.Vector3()},
  uInvProj: {value: new THREE.Matrix4()},
  uInvView: {value: new THREE.Matrix4()},
  uSeed: {value: 1234.0},
  uDepth: {value: 2},
  uSteps: {value: 80},
  uTunnelRadius: {value: 5.0},
  uSegmentLen: {value: 8.0}
};

const tunnelMat = new THREE.RawShaderMaterial({
  vertexShader: tunnelVS,
  fragmentShader: tunnelFS,
  uniforms: tunnelUniforms,
  glslVersion: THREE.GLSL3,
  depthWrite: false,
  depthTest: false,
});

const quadGeo = new THREE.BufferGeometry();
const quadVerts = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
quadGeo.setAttribute('aPos', new THREE.BufferAttribute(quadVerts, 2));
const tunnelQuad = new THREE.Mesh(quadGeo, tunnelMat);
tunnelQuad.frustumCulled = false;
tunnelQuad.renderOrder = -999; // render first (as background)
scene.add(tunnelQuad);

// Hook seed/depth controls to shader uniforms
function setTunnelSeedDepth(seedVal, depthVal){
  tunnelUniforms.uSeed.value = seedVal;
  tunnelUniforms.uDepth.value = depthVal;
  // tune radius/segment by depth for interesting variety
  tunnelUniforms.uTunnelRadius.value = 4.0 + depthVal*0.8;
  tunnelUniforms.uSegmentLen.value = 8.0 - Math.min(6, depthVal*0.6);
}

// In render loop (animate) update shader uniforms each frame
const _invProj = new THREE.Matrix4();
const _invView = new THREE.Matrix4();
function updateTunnelUniforms(timeSec){
  tunnelUniforms.uTime.value = timeSec;
  tunnelUniforms.uRes.value.set(window.innerWidth, window.innerHeight);
  tunnelUniforms.uCamPos.value.copy(camera.position);
  // inverse projection and inverse view (camera.matrixWorld is inverse of view)
  _invProj.copy(camera.projectionMatrix).invert();
  _invView.copy(camera.matrixWorld); // camera.matrixWorld = inverse(viewMatrix)
  tunnelUniforms.uInvProj.value.copy(_invProj);
  tunnelUniforms.uInvView.value.copy(_invView);
}

// replace the old basic tunnel mesh if present
const oldTunnel = scene.getObjectByName("tunnel");
if(oldTunnel) scene.remove(oldTunnel);

// Update: call updateTunnelUniforms inside the render loop in Chunk 4/5
// Example usage: setTunnelSeedDepth(12345, 2)
</html>
// ========== Chunk 3/5 ==========
// Weapon generation
function generateWeapon() {
    const types = ["laser", "bullet", "flamethrower", "beam"];
    const type = types[Math.floor(Math.random() * types.length)];
    const power = Math.random() * 5 + 1;
    const color = new THREE.Color(Math.random(), Math.random(), Math.random());
    return { type, power, color };
}

// Enemy generation
function generateEnemy() {
    const geometry = new THREE.IcosahedronGeometry(Math.random() * 2 + 1, 1);
    const color = new THREE.Color(Math.random(), Math.random(), Math.random());
    const material = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color.clone().multiplyScalar(0.5),
        flatShading: true
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(Math.random() * 20 - 10, 1, Math.random() * -20);
    mesh.health = Math.random() * 50 + 50;
    scene.add(mesh);
    enemies.push(mesh);
}

// Shooting mechanic
function shootWeapon() {
    if (!currentWeapon) return;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(enemies);

    if (intersects.length > 0) {
        const enemy = intersects[0].object;
        enemy.health -= currentWeapon.power * 10;
        if (enemy.health <= 0) {
            scene.remove(enemy);
            enemies.splice(enemies.indexOf(enemy), 1);
        }
    }
}

// Fractal tunnel generation
function generateFractalTunnel(seed) {
    const random = new Math.seedrandom(seed);
    const tunnelLength = 200;
    const tunnelGeometry = new THREE.CylinderGeometry(10, 10, tunnelLength, 64, 1, true);
    const tunnelMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(random(), random(), random()),
        emissive: new THREE.Color(random(), random(), random()),
        side: THREE.BackSide,
        wireframe: false
    });
    const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
    tunnel.rotation.x = Math.PI / 2;
    scene.add(tunnel);
    fractalTunnels.push(tunnel);
}
// ========== Chunk 4/5 ==========
// Room generation along fractal tunnel
function generateRoom(seed) {
    const random = new Math.seedrandom(seed);
    const roomSize = 30;
    const geometry = new THREE.BoxGeometry(roomSize, roomSize, roomSize);
    const color = new THREE.Color(random(), random(), random());
    const material = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color.clone().multiplyScalar(0.3),
        side: THREE.BackSide
    });
    const room = new THREE.Mesh(geometry, material);
    room.position.set(
        (random() - 0.5) * 100,
        (random() - 0.5) * 50,
        (random() - 0.5) * 300
    );
    scene.add(room);
    fractalRooms.push(room);

    // Spawn enemies in the room
    for (let i = 0; i < 5 + Math.floor(random() * 5); i++) {
        const enemy = generateEnemy();
        enemy.position.add(room.position.clone().add(new THREE.Vector3(
            (random() - 0.5) * 20,
            1,
            (random() - 0.5) * 20
        )));
    }

    // Spawn loot in the room
    for (let i = 0; i < 3; i++) {
        const lootGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const lootMaterial = new THREE.MeshStandardMaterial({
            color: new THREE.Color(random(), random(), random()),
            emissive: new THREE.Color(random(), random(), random())
        });
        const loot = new THREE.Mesh(lootGeometry, lootMaterial);
        loot.position.copy(room.position.clone().add(new THREE.Vector3(
            (random() - 0.5) * 10,
            1,
            (random() - 0.5) * 10
        )));
        loot.isLoot = true;
        scene.add(loot);
        lootItems.push(loot);
    }
}

// Detect portal collisions to move between rooms
function checkPortalCollisions() {
    for (let i = 0; i < fractalRooms.length; i++) {
        const dist = camera.position.distanceTo(fractalRooms[i].position);
        if (dist < 5) {
            // Player reached a room
            currentRoomIndex = i;
            console.log("Entered room", i);
        }
    }
}

// Loot collection
function collectLoot() {
    for (let i = lootItems.length - 1; i >= 0; i--) {
        if (camera.position.distanceTo(lootItems[i].position) < 2) {
            scene.remove(lootItems[i]);
            lootItems.splice(i, 1);
            console.log("Loot collected!");
        }
    }
}
// ========== Chunk 5/5 ==========
// Input handling
document.addEventListener('keydown', (event) => {
    keys[event.code] = true;
});
document.addEventListener('keyup', (event) => {
    keys[event.code] = false;
});

// Mouse look
document.addEventListener('mousemove', (event) => {
    if (document.pointerLockElement === document.body) {
        camera.rotation.y -= event.movementX * mouseSensitivity;
        camera.rotation.x -= event.movementY * mouseSensitivity;
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
    }
});
document.body.addEventListener('click', () => {
    document.body.requestPointerLock();
});

// Shooting
document.addEventListener('mousedown', () => {
    const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.1, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
    );
    bullet.position.copy(camera.position);
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    bullet.velocity = dir.multiplyScalar(1);
    scene.add(bullet);
    bullets.push(bullet);
});

// Movement update
function updatePlayer() {
    const forward = new THREE.Vector3(Math.sin(camera.rotation.y), 0, Math.cos(camera.rotation.y));
    const right = new THREE.Vector3(Math.cos(camera.rotation.y), 0, -Math.sin(camera.rotation.y));
    if (keys['KeyW']) camera.position.add(forward.multiplyScalar(playerSpeed));
    if (keys['KeyS']) camera.position.add(forward.multiplyScalar(-playerSpeed));
    if (keys['KeyA']) camera.position.add(right.multiplyScalar(-playerSpeed));
    if (keys['KeyD']) camera.position.add(right.multiplyScalar(playerSpeed));
}

// Bullet update
function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].position.add(bullets[i].velocity);
        // Remove if too far
        if (bullets[i].position.length() > 1000) {
            scene.remove(bullets[i]);
            bullets.splice(i, 1);
        }
        // Check collision with enemies
        for (let j = enemies.length - 1; j >= 0; j--) {
            if (bullets[i] && bullets[i].position.distanceTo(enemies[j].position) < 1) {
                scene.remove(enemies[j]);
                enemies.splice(j, 1);
                scene.remove(bullets[i]);
                bullets.splice(i, 1);
                console.log("Enemy down!");
                break;
            }
        }
    }
}

// Main game loop
function animate() {
    requestAnimationFrame(animate);
    updatePlayer();
    updateBullets();
    checkPortalCollisions();
    collectLoot();
    renderer.render(scene, camera);
}
animate();

// Generate initial fractal tunnel & rooms
for (let s = 0; s < 10; s++) {
    generateRoom("seed_" + s);
}
