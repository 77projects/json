<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fractal Worlds — Mandelbrot Levels (Trippy Bosses) — Ultra</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #000; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #ui { position: fixed; inset: 0; pointer-events: none; }
    .hud { position: absolute; left: 12px; top: 12px; pointer-events: auto; background: rgba(0,0,0,.55); color: #e6f3ff; padding: 10px 12px; border-radius: 10px; backdrop-filter: blur(4px); box-shadow: 0 10px 25px rgba(0,0,0,.35); }
    .row { display:flex; align-items:center; gap:.5rem; margin:.35rem 0; }
    button, input[type="number"], input[type="range"] { pointer-events:auto; background:#0a0f1a; border:1px solid #2a3142; color:#cfe8ff; padding:.45rem .6rem; border-radius:10px; outline:none; }
    button:hover { background:#0f1626; }
    label { font-size: 12px; opacity:.9; }
    .big { font-size: 18px; font-weight: 650; }
    .faint { opacity:.8; }
    .badge { background:#0f243a; border:1px solid #2a496b; padding:.2rem .45rem; border-radius:999px; font-size:12px; }
    .crosshair { position: absolute; left:50%; top:50%; transform: translate(-50%, -50%); color:#fff; font-size:10px; opacity:.8; pointer-events:none; }
    .centerHint { position:absolute; left:50%; bottom: 10%; transform: translateX(-50%); color:#fff; background: rgba(0,0,0,.45); padding:.6rem .8rem; border-radius: 12px; font-size: 14px; pointer-events: none; }
    .toast { position:absolute; right:12px; top:12px; background:rgba(0,0,0,.55); color:#dff2ff; padding:.5rem .75rem; border-radius:10px; pointer-events:none; min-width: 200px; text-align:right; }
    .bar { height: 8px; background: linear-gradient(90deg,#00ffe7,#7f00ff,#ff0080); filter: saturate(1.4); border-radius: 999px; box-shadow: inset 0 0 12px rgba(255,255,255,.15); }
    .bottomHud { position:absolute; left:12px; bottom:12px; display:flex; gap:12px; align-items:center; }
    .stat { background: rgba(0,0,0,.55); color:#cfe8ff; padding:.35rem .6rem; border-radius:10px; font-size: 12px; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="hud" style="min-width: 320px;">
      <div class="big">Mandelbrot → Level Generator</div>
      <div class="row"><label>Seed base:</label><input id="seedBase" type="number" value="1337" min="0" step="1" style="width:110px;"/><span class="badge" id="derivedSeed">Derived: —</span></div>
      <div class="row"><label>Base platforms:</label><input id="platforms" type="number" value="18" min="3" max="99"/></div>
      <div class="row" style="gap:.4rem;flex-wrap:wrap">
        <button id="btnStart">Start / Lock Pointer</button>
        <button id="btnGenerate">Generate Level From View</button>
        <button id="btnNewWorld">Enter New World</button>
        <button id="btnBoss">Summon Boss</button>
      </div>
      <div class="row"><span>Center:</span><span id="center">—</span></div>
      <div class="row"><label>Zoom:</label><span id="zoom">1 ×</span></div>
      <div class="row faint">Click Mandelbrot to spawn a full trippy level at that complex coordinate. Zoom deeper to vary level complexity.</div>
      <div class="row"><span class="badge" id="fps">FPS: 0</span><span class="badge" id="enemies">Enemies: 0</span><span class="badge" id="world">World: 0</span></div>
    </div>
    <div class="bottomHud">
      <div class="stat">WASD move, Space jump, Shift sprint, Mouse look, Left click shoot, R reload</div>
      <div class="stat">HP: <span id="hp">100</span></div>
      <div class="stat">Ammo: <span id="ammo">30</span>/<span id="reserve">120</span></div>
      <div class="stat">Level: <span id="level">1</span></div>
    </div>
    <div class="crosshair">✚</div>
    <div class="centerHint" id="centerHint">Click Start to Lock Pointer</div>
    <div class="toast" id="toast" style="display:none"></div>
  </div>  <script type="module">
    // External deps (ESM)
    import * as THREE from "https://unpkg.com/three@0.160.1/build/three.module.js";
    import { PointerLockControls } from "https://unpkg.com/three@0.160.1/examples/jsm/controls/PointerLockControls.js";

    // ===== Utilities =====
    const rand = (seed => () => (seed = (seed * 1664525 + 1013904223) >>> 0) / 2**32)(1337);
    const hrand = (h) => { // string/number -> deterministic 0..1
      const s = (typeof h === 'number' ? h.toString(36) : h);
      let x = 0x811c9dc5;
      for (let i=0;i<s.length;i++) { x ^= s.charCodeAt(i); x = Math.imul(x, 0x01000193); }
      return (x >>> 0) / 2**32;
    };
    const choice = (arr, r=Math.random()) => arr[Math.floor(r * arr.length)];

    // Simplex-ish noise via layered sin waves (fast & shader-friendly)
    const noise3 = (x,y,z)=>{
      return (Math.sin(x*1.7+y*1.3+z*0.7)+Math.sin(x*0.5-y*2.1+z*1.9)+Math.sin(-x*2.3+y*0.9-z*1.3))*0.3333;
    };

    // ===== Scene Setup =====
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 5000);
    const controls = new PointerLockControls(camera, renderer.domElement);
    camera.position.set(0, 2, 5);

    // Trippy sky shader (animated HSV gradient with fractal ripples)
    const skyUniforms = {
      t: { value: 0 },
      palette: { value: new THREE.Vector4(Math.random(), Math.random(), Math.random(), Math.random()) },
    };
    const skyMat = new THREE.ShaderMaterial({
      side: THREE.BackSide,
      uniforms: skyUniforms,
      vertexShader:`varying vec3 vPos; void main(){ vPos=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.); }`,
      fragmentShader:`
        varying vec3 vPos; uniform float t; uniform vec4 palette;
        float hash(vec2 p){ return fract(sin(dot(p, vec2(41.31,97.13)))*43758.5453); }
        vec3 hsv2rgb(vec3 c){ vec4 K=vec4(1.,2./3.,1./3.,3.); vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www); return c.z*mix(K.xxx, clamp(p-K.xxx,0.,1.), c.y); }
        void main(){
          vec3 p = normalize(vPos);
          float r = length(p.xz);
          float m = 0.0;
          vec2 q = p.xz*1.7 + vec2(t*0.05, -t*0.03);
          for (int i=0;i<4;i++) { q = vec2(q.x+sin(q.y*1.7), q.y+cos(q.x*1.3)); m += sin(q.x+q.y + float(i)*1.3); }
          m = m*0.125 + 0.5 + 0.25*sin(r*12. + t*0.6);
          vec3 hsv = vec3(fract(palette.x + m*0.2 + t*0.02), 0.7 + 0.3*sin(t*0.2), 0.6 + 0.4*m);
          gl_FragColor = vec4(hsv2rgb(hsv), 1.0);
        }`
    });
    const skyGeo = new THREE.SphereGeometry(1500, 64, 32);
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x110022, 0.8); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,10,2); scene.add(dir);

    // Ground (procedural color)
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x111318, roughness: 0.9, metalness: 0.0 });
    const ground = new THREE.Mesh(new THREE.CylinderGeometry(400,400,2,64), groundMat);
    ground.position.y = -1; ground.receiveShadow = true; scene.add(ground);

    // ===== UI elements =====
    const $ = sel => document.querySelector(sel);
    const fpsEl = $('#fps'), hpEl=$('#hp'), ammoEl=$('#ammo'), resEl=$('#reserve'), lvlEl=$('#level'), toast=$('#toast'), worldEl=$('#world');
    let hp=100, ammo=30, reserve=120, level=1, world=0;

    // ===== Player / movement =====
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const key = {};
    addEventListener('keydown', e=> key[e.code]=true);
    addEventListener('keyup', e=> key[e.code]=false);

    let canJump = false;
    let lastOnGroundY = 0;

    // Basic collision proxies
    const colliders = [];

    function addCollider(mesh, radius=1.0, height=2.5) {
      mesh.userData.collider = { radius, height };
      colliders.push(mesh);
    }

    // ===== Weapons =====
    const bullets = [];
    function shoot(){
      if(ammo<=0){ notify('Out of ammo — press R to reload'); return; }
      ammo--; updateAmmo();
      const geo = new THREE.SphereGeometry(0.05,8,8);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const b = new THREE.Mesh(geo, mat);
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
      b.position.copy(camera.position).add(dir.clone().multiplyScalar(0.8));
      b.userData.vel = dir.multiplyScalar(120);
      scene.add(b); bullets.push(b);
    }
    function reload(){
      if(reserve<=0||ammo>=30) return; const need = 30-ammo; const take = Math.min(need,reserve); ammo+=take; reserve-=take; updateAmmo(); }

    addEventListener('mousedown', e=>{ if(document.pointerLockElement===renderer.domElement) shoot(); });
    addEventListener('keydown', e=>{ if(e.code==='KeyR') reload(); });

    function updateAmmo(){ ammoEl.textContent=ammo; resEl.textContent=reserve; }

    // ===== Enemies & Bosses =====
    const enemies=[]; let boss=null;
    const enemyTypes = {
      Chaser: (seed)=>{
        const g = new THREE.DodecahedronGeometry(0.7+hrand(seed)*0.5);
        const m = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed*7), 0.9, 0.55), emissive: 0x111111, roughness:0.3, metalness:0.4 });
        const e = new THREE.Mesh(g,m); e.userData={hp:20+Math.floor(hrand(seed)*20), speed: 4+hrand(seed)*3, type:'Chaser'}; return e;
      },
      Shooter: (seed)=>{
        const g = new THREE.ConeGeometry(0.6,1.2, 6+Math.floor(hrand(seed)*8));
        const m = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed*11), 0.8, 0.6), emissive: 0x220022, roughness:0.2, metalness:0.6 });
        const e = new THREE.Mesh(g,m); e.userData={hp:28, speed:3.2, shootCooldown: 0, type:'Shooter'}; return e;
      },
      Blinker: (seed)=>{
        const g = new THREE.TorusKnotGeometry(0.5,0.18, 64, 8, 2+Math.floor(hrand(seed)*3), 3+Math.floor(hrand(seed*3)*2));
        const m = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed*13), 1.0, 0.5), emissive: 0x001133, roughness:0.4, metalness:0.5 });
        const e = new THREE.Mesh(g,m); e.userData={hp:18, speed:2.2, blinkCD: 0, type:'Blinker'}; return e;
      }
    };

    function spawnEnemy(pos, seed){
      const t = choice(Object.keys(enemyTypes), hrand(seed));
      const e = enemyTypes[t](seed);
      e.position.copy(pos);
      e.castShadow = true; e.receiveShadow = true;
      scene.add(e); enemies.push(e);
      return e;
    }

    function spawnBoss(seed){
      if (boss) { notify('Boss already active!'); return; }
      const g = new THREE.IcosahedronGeometry(4,2);
      const m = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed), 0.85, 0.55), metalness:0.8, roughness:0.2, emissive:0x220033, emissiveIntensity:0.6, wireframe:false });
      boss = new THREE.Mesh(g,m);
      boss.position.set(0, 6, -35);
      boss.userData = { hp: 600, t: 0, phase: 1 };
      scene.add(boss);
      notify('⚠ Boss has entered the arena!');
    }

    // ===== World Assets (random appearances) =====
    const worldGroup = new THREE.Group(); scene.add(worldGroup);

    function clearWorld(){
      for (let i=worldGroup.children.length-1;i>=0;i--) worldGroup.remove(worldGroup.children[i]);
      enemies.splice(0,enemies.length);
      for (let i=bullets.length-1;i>=0;i--) { scene.remove(bullets[i]); bullets.splice(i,1); }
      boss=null; colliders.length=0;
    }

    function addAsset(seed, x, z){
      const kind = Math.floor(hrand(seed)*5);
      let mesh;
      if(kind===0){ // crystal
        mesh = new THREE.Mesh(new THREE.OctahedronGeometry(0.7+hrand(seed*3)*2, 0), new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed*5), 0.9, 0.6), metalness:0.7, roughness:0.15, emissive:0x001122 }));
      } else if(kind===1){ // pillar
        mesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 2+hrand(seed)*5, 8, 16), new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed*7), 0.7, 0.5), metalness:0.3, roughness:0.8 }));
      } else if(kind===2){ // ring
        mesh = new THREE.Mesh(new THREE.TorusGeometry(1.2+hrand(seed), 0.15+hrand(seed*2)*0.25, 16, 64), new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed*9), 1.0, 0.5), metalness:0.6, roughness:0.25 }));
        mesh.rotation.x = Math.random()*Math.PI;
      } else if(kind===3){ // spinner
        mesh = new THREE.Mesh(new THREE.TetrahedronGeometry(0.9+hrand(seed), 0), new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed*11), 0.9, 0.5), metalness:0.8, roughness:0.2 }));
        mesh.userData.spin = (hrand(seed*13)-0.5)*2;
      } else { // arch
        const g = new THREE.TorusGeometry(1.8+hrand(seed), 0.25, 12, 48, Math.PI);
        mesh = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed*15), 0.8, 0.6), metalness:0.5, roughness:0.35 }));
        mesh.rotation.z = Math.PI/2;
      }
      mesh.position.set(x, 0, z);
      worldGroup.add(mesh);
      if (kind===1) addCollider(mesh, 0.7, 3.5);
    }

    // Platforms / walkable islands
    function addPlatform(seed, x, z, r){
      const geom = new THREE.CylinderGeometry(r, r*1.1, 1.2, 24+Math.floor(hrand(seed)*24));
      const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed*17), 0.6, 0.35), metalness:0.2, roughness:0.9 });
      const p = new THREE.Mesh(geom, mat); p.position.set(x, -0.4, z); p.receiveShadow = true; worldGroup.add(p);
      addCollider(p, r, 1.2);
      return p;
    }

    // ===== Mandelbrot-ish seed from camera view & pointer clicks =====
    let fractalCenter = { x:-0.5, y:0.0 }, fractalZoom = 1.0;
    const centerEl = document.getElementById('center');
    const zoomEl = document.getElementById('zoom');

    function updateFractalDisplay(){
      centerEl.textContent = `(${fractalCenter.x.toFixed(4)} + ${fractalCenter.y.toFixed(4)}i)`;
      zoomEl.textContent = `${fractalZoom.toFixed(2)} ×`;
    }

    function deriveSeedFromView(){
      // Hash camera orientation + fractal params to a stable seed
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
      const s = `${fractalCenter.x.toFixed(4)}:${fractalCenter.y.toFixed(4)}:${fractalZoom.toFixed(2)}:${dir.toArray().map(v=>v.toFixed(3)).join(',')}`;
      const seed = Math.floor(hrand(s)*1e9);
      document.getElementById('derivedSeed').textContent = `Derived: ${seed}`;
      return seed;
    }

    // ===== World Generation =====
    function generateWorld(seedBase, platformCount){
      clearWorld();
      level=1; hp=100; ammo=30; reserve=120; updateAmmo(); hpEl.textContent=hp; lvlEl.textContent=level; world++;
      worldEl.textContent = world;

      // Randomize sky palette
      skyUniforms.palette.value = new THREE.Vector4(hrand(seedBase*3), hrand(seedBase*5), hrand(seedBase*7), hrand(seedBase*11));

      const rng = (mul=1)=> (hrand(seedBase = Math.imul(seedBase, 1103515245) + 12345) * mul);

      // Platforms arranged in spiral/constellation based on fractal-ish iterations
      const radiusBase = 8 + rng(10);
      let angle = rng(Math.PI*2);
      for(let i=0;i<platformCount;i++){
        const r = radiusBase + i*2.5 + Math.sin(i*0.7+seedBase)*2.0;
        angle += 0.7 + Math.sin(i*0.23)*0.35;
        const x = Math.cos(angle)*r;
        const z = Math.sin(angle)*r;
        const plat = addPlatform(seedBase+i, x, z, 3.2 + (i%3)*0.6 + rng(1.5));

        // Sprinkle assets
        for(let k=0;k<3;k++){
          const ox = x + (rng(1)-0.5)*4.5;
          const oz = z + (rng(1)-0.5)*4.5;
          addAsset(seedBase+i*31+k, ox, oz);
        }

        // Spawn enemies around later platforms
        if (i>4 && i%2===0){
          const epos = new THREE.Vector3(x+(rng(1)-0.5)*3, 0.6, z+(rng(1)-0.5)*3);
          spawnEnemy(epos, seedBase+i*101);
        }
      }

      // Add a portal to the next world
      addPortal(new THREE.Vector3(0, 1.4, -radiusBase-10), seedBase^0x9e3779b1);

      // Place player
      camera.position.set(0, 2.2, radiusBase+6);
      controls.getObject().position.copy(camera.position);
    }

    function addPortal(pos, seed){
      const ring = new THREE.Mesh(new THREE.TorusGeometry(2.3, 0.22, 16, 64), new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(hrand(seed), 0.9, 0.6), metalness:0.7, roughness:0.15, emissive:0x111122 }));
      ring.position.copy(pos);
      const swirl = new THREE.Mesh(new THREE.RingGeometry(0.2, 2.1, 64), new THREE.ShaderMaterial({
        side: THREE.DoubleSide, transparent:true,
        uniforms: { t: { value: 0 }, hue: { value: hrand(seed*3) } },
        vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.); }`,
        fragmentShader:`varying vec2 vUv; uniform float t; uniform float hue; vec3 hsv2rgb(vec3 c){ vec4 K=vec4(1.,2./3.,1./3.,3.); vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www); return c.z*mix(K.xxx, clamp(p-K.xxx,0.,1.), c.y);} void main(){ float r=distance(vUv, vec2(0.5)); float a=smoothstep(0.45,0.48,r)* (1.-smoothstep(0.48,0.5,r)); float m=0.5+0.5*sin(40.*r - t*4.); vec3 col=hsv2rgb(vec3(fract(hue+m*0.1), 0.9, 0.8)); gl_FragColor=vec4(col, a); }`
      }));
      ring.userData.swirl = swirl; swirl.position.copy(pos); swirl.rotation.y = Math.PI/2;
      worldGroup.add(ring); worldGroup.add(swirl);
      ring.userData.portal = true;
      addCollider(ring, 2.5, 4);
    }

    // ===== Input UI =====
    $('#btnStart').onclick = ()=>{
      renderer.domElement.requestPointerLock();
      $('#centerHint').style.display='none';
      controls.lock();
    };
    $('#btnGenerate').onclick = ()=>{ const seed = deriveSeedFromView() ^ parseInt($('#seedBase').value||0,10); generateWorld(seed, parseInt($('#platforms').value,10)||18); };
    $('#btnNewWorld').onclick = ()=>{ generateWorld((Math.random()*1e9)|0, parseInt($('#platforms').value,10)||18); };
    $('#btnBoss').onclick = ()=>{ spawnBoss((Math.random()*1e9)|0); };

    // ===== Game Loop =====
    let last = performance.now(); let acc = 0; const fixedDt = 1/120; let frames=0, fps=0, tFps=0;

    function step(dt){
      skyUniforms.t.value += dt;

      // Controls
      direction.set(0,0,0);
      if(key['KeyW']) direction.z -= 1; if(key['KeyS']) direction.z += 1; if(key['KeyA']) direction.x -= 1; if(key['KeyD']) direction.x += 1;
      direction.normalize();

      const speed = key['ShiftLeft']? 11: 7;
      const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).multiplyScalar(-1);
      controls.getObject().position.add(forward.multiplyScalar(direction.z*speed*dt));
      controls.getObject().position.add(right.multiplyScalar(direction.x*speed*dt));

      // Gravity & floor
      velocity.y -= 20*dt;
      controls.getObject().position.y += velocity.y*dt;
      if (controls.getObject().position.y < 1.8) { controls.getObject().position.y = 1.8; velocity.y=0; canJump=true; }
      if (key['Space'] && canJump) { velocity.y = 8; canJump=false; }

      // Spinny assets
      for (const m of worldGroup.children){ if (m.userData.spin) m.rotation.y += m.userData.spin*dt; if (m.userData.swirl) m.userData.swirl.material.uniforms.t.value += dt; }

      // Bullet updates & hit detection
      for (let i=bullets.length-1;i>=0;i--){
        const b = bullets[i]; b.position.addScaledVector(b.userData.vel, dt);
        // hit enemies
        for (let j=enemies.length-1;j>=0;j--){ const e=enemies[j]; if (b.position.distanceTo(e.position) < 0.8){ e.userData.hp -= 12; scene.remove(b); bullets.splice(i,1); if(e.userData.hp<=0){ scene.remove(e); enemies.splice(j,1);} break; } }
        if (boss && b.position.distanceTo(boss.position) < 5){ boss.userData.hp -= 8; scene.remove(b); bullets.splice(i,1); if (boss.userData.hp<=0){ notify('Boss defeated!'); scene.remove(boss); boss=null; level++; lvlEl.textContent=level; } }
        // lifespan
        if (b.position.length() > 1500){ scene.remove(b); bullets.splice(i,1); }
      }

      // Enemy AI
      for (const e of enemies){
        const toPlayer = camera.position.clone().sub(e.position); const dist = toPlayer.length(); toPlayer.normalize();
        if (e.userData.type==='Chaser'){
          e.position.add(toPlayer.multiplyScalar(e.userData.speed*dt));
        } else if (e.userData.type==='Shooter'){
          e.lookAt(camera.position);
          e.userData.shootCooldown -= dt;
          if (dist<24 && e.userData.shootCooldown<=0){
            e.userData.shootCooldown = 1.2 + hrand(e.id||1)*0.6;
            // enemy projectile
            const g = new THREE.SphereGeometry(0.12, 10, 10);
            const m = new THREE.MeshBasicMaterial({ color: 0xff3355 });
            const p = new THREE.Mesh(g,m); p.position.copy(e.position);
            p.userData.vel = camera.position.clone().sub(e.position).normalize().multiplyScalar(12);
            p.userData.enemy=true; scene.add(p); bullets.push(p);
          }
        } else if (e.userData.type==='Blinker'){
          e.userData.blinkCD -= dt; if (e.userData.blinkCD<=0){ e.userData.blinkCD = 1.5+hrand(e.id||2); const off = new THREE.Vector3((Math.random()-0.5)*6, 0, (Math.random()-0.5)*6); e.position.copy(camera.position.clone().add(off)); }
        }
        // damage to player if close
        if (dist<1.3){ hp -= 12*dt; hpEl.textContent = Math.max(0, hp|0); if (hp<=0){ notify('You died — generating new world'); generateWorld((Math.random()*1e9)|0, parseInt($('#platforms').value,10)||18); return; } }
      }

      // Boss behaviors
      if (boss){
        boss.userData.t += dt; boss.rotation.y += 0.3*dt; boss.position.x = Math.sin(boss.userData.t*0.7)*15; boss.position.z = -25 + Math.cos(boss.userData.t*0.6)*10;
        if (boss.userData.t % 2.5 < dt){ // radial burst
          for (let k=0;k<24;k++){ const a = (k/24)*Math.PI*2; const p = new THREE.Mesh(new THREE.SphereGeometry(0.15,12,12), new THREE.MeshBasicMaterial({ color: 0x66ccff })); p.position.copy(boss.position); p.userData.vel = new THREE.Vector3(Math.cos(a), 0, Math.sin(a)).multiplyScalar(14); p.userData.enemy=true; scene.add(p); bullets.push(p);} }
      }

      // Enemy bullets hit player
      for (let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; if (!b.userData.enemy) continue; if (b.position.distanceTo(camera.position)<1.0){ hp -= 22; hpEl.textContent=Math.max(0,hp|0); scene.remove(b); bullets.splice(i,1); if(hp<=0){ notify('You died — generating new world'); generateWorld((Math.random()*1e9)|0, parseInt($('#platforms').value,10)||18); return; } } }

      // HUD
      enemies.length && (enemies[0].material.emissiveIntensity = 0.2 + 0.2*Math.sin(performance.now()/300));
      document.getElementById('enemies').textContent = `Enemies: ${enemies.length}`;
    }

    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000); last = now; acc += dt; tFps += dt; frames++;
      while(acc>=fixedDt){ step(fixedDt); acc -= fixedDt; }
      if (tFps>=0.5){ fps = Math.round(frames/tFps); fpsEl.textContent = `FPS: ${fps}`; frames=0; tFps=0; }

      // Keep camera inside sky sphere
      sky.position.copy(camera.position);

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    // Resize
    addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    function notify(msg){ toast.style.display='block'; toast.textContent = msg; clearTimeout(notify.t); notify.t = setTimeout(()=> toast.style.display='none', 2400); }

    // Initial world
    function firstBoot(){ updateFractalDisplay(); generateWorld((Math.random()*1e9)|0, parseInt($('#platforms').value,10)||18); }

    // pointer lock hints
    document.addEventListener('pointerlockchange', ()=>{ if(document.pointerLockElement===renderer.domElement){ $('#centerHint').style.display='none'; } else { $('#centerHint').style.display='block'; }});

    // Fire it up
    firstBoot();
    requestAnimationFrame(loop);
  </script></body>
</html>
