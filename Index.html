<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Neon Fractal FPS - Fixed FPS</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #000;
    font-family: 'Orbitron', sans-serif;
    color: #0ff;
    user-select: none;
  }
  #overlay {
    position: absolute;
    top: 10px; left: 10px;
    z-index: 10;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 8px;
  }
  #seedInput, #depthInput {
    width: 140px;
    background: #111;
    border: 1px solid #0ff;
    color: #0ff;
    font-family: 'Orbitron', monospace;
    font-size: 14px;
    padding: 4px;
    margin-bottom: 6px;
  }
  button {
    background: #0ff;
    border: none;
    color: #000;
    font-weight: bold;
    font-family: 'Orbitron', monospace;
    cursor: pointer;
    padding: 6px 12px;
    border-radius: 6px;
    margin-left: 4px;
  }
  button:hover {
    background: #0cc;
  }
  #weapon {
    position: absolute;
    bottom: 20px;
    right: 40px;
    width: 180px;
    height: 100px;
    pointer-events: none;
  }
  #weapon canvas {
    width: 100%; height: 100%;
    image-rendering: pixelated;
  }
  #fpsCounter {
    position: fixed !important;
    top: 10px !important;
    right: 10px !important;
    font-size: 24px !important;
    color: #0ff !important;
    z-index: 9999 !important;
    user-select: none !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>

<div id="overlay">
  <div>Seed: <input type="text" id="seedInput" value="12345" /></div>
  <div>Depth: <input type="number" id="depthInput" value="3" min="1" max="10" /></div>
  <button id="startBtn">Enter Fractal</button>
</div>

<div id="fpsCounter">FPS: 0</div>

<canvas id="weapon" width="320" height="180"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  // RNG helper with seed
  class RNG {
    constructor(seed) {
      this.seed = seed % 2147483647;
      if(this.seed <= 0) this.seed += 2147483646;
    }
    next() {
      return this.seed = this.seed * 16807 % 2147483647;
    }
    nextFloat() {
      return (this.next() - 1) / 2147483646;
    }
    nextRange(min, max) {
      return min + this.nextFloat() * (max - min);
    }
    nextInt(min, max) {
      return Math.floor(this.nextRange(min, max+1));
    }
  }

   // Globals
  let scene, camera, renderer, controls;
  let fractalGroup;
  let enemies = [];
  let bullets = [];
  let clock, deltaTime;
  let rng;
  let player = {
    velocity: new THREE.Vector3(),
    speed: 6,
    bulletCooldown: 0,
    hp: 100,
  };
  let weapons = [
    { name:"Laser Blaster", color:"#0ff", bulletSpeed:70, bulletSize:0.1, damage:10, beam:false, flamethrower:false },
    { name:"Flame Thrower", color:"#f50", bulletSpeed:40, bulletSize:0.15, damage:2, beam:false, flamethrower:true },
    { name:"Neon Cannon", color:"#f0f", bulletSpeed:50, bulletSize:0.3, damage:20, beam:false, flamethrower:false },
    { name:"Focused Beam", color:"#ff0", bulletSpeed:100, bulletSize:0.05, damage:5, beam:true, flamethrower:false }
  ];
  let currentWeapon;
  let weaponCanvas, weaponCtx;

  // HTML elements
  const seedInput = document.getElementById("seedInput");
  const depthInput = document.getElementById("depthInput");
  const startBtn = document.getElementById("startBtn");
  const fpsCounter = document.getElementById("fpsCounter");
  weaponCanvas = document.getElementById("weapon");
  weaponCtx = weaponCanvas.getContext("2d");

  // Init three.js
  function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    controls = new THREE.PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.body.addEventListener('click', () => {
      controls.lock();
    }, {once:true});
  }

  // Create fractal tunnel (low poly neon style)
  function createFractalTunnel(depth, baseRadius=5, length=10) {
    const group = new THREE.Group();

    const geometry = new THREE.CylinderGeometry(baseRadius, baseRadius, length, 12, 1, true);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      wireframe: true,
      transparent: true,
      opacity: 0.3
    });
    for(let i=0; i<depth; i++) {
      let mesh = new THREE.Mesh(geometry, material.clone());
      mesh.position.z = -length * i;
      mesh.material.color.setHSL(i/depth, 1, 0.5);
      group.add(mesh);
    }

    return group;
  }

  // Generate rooms at fractal points
  function createRoom(seed, index) {
    const room = new THREE.Group();
    let localRng = new RNG(seed + index*997);

    const roomSize = 6;
    const geometry = new THREE.BoxGeometry(roomSize, roomSize, roomSize);
    const edges = new THREE.EdgesGeometry(geometry);
    const lineMat = new THREE.LineBasicMaterial({color: 0xff00ff});
    const roomBox = new THREE.LineSegments(edges, lineMat);
    room.add(roomBox);
    room.position.z = -index * 10;

    // Add random enemies
    let enemyCount = localRng.nextInt(3, 6);
    for(let i=0; i<enemyCount; i++) {
      let enemy = createEnemy(localRng);
      enemy.position.set(
        localRng.nextRange(-roomSize/2+1, roomSize/2-1),
        localRng.nextRange(-roomSize/2+1, roomSize/2-1),
        room.position.z + localRng.nextRange(-roomSize/2+1, roomSize/2-1)
      );
      room.add(enemy);
      enemies.push(enemy);
    }

    return room;
  }

  // Create enemy mesh (low-poly neon)
  function createEnemy(rng) {
    const geometry = new THREE.TetrahedronGeometry(0.5);
    const colorHue = rng.nextFloat();
    const material = new THREE.MeshBasicMaterial({color: new THREE.Color().setHSL(colorHue, 1, 0.5), wireframe:true});
    const enemy = new THREE.Mesh(geometry, material);
    enemy.userData = { hp: 10 + Math.floor(rng.nextFloat()*20), alive:true, velocity: new THREE.Vector3() };
    return enemy;
  }

  // Generate a random weapon based on seed
  function generateWeapon(seed) {
    const weaponIndex = seed % weapons.length;
    return weapons[weaponIndex];
  }

  // Draw weapon on canvas (simple neon low-poly style)
  function drawWeapon() {
    weaponCtx.clearRect(0, 0, weaponCanvas.width, weaponCanvas.height);
    weaponCtx.strokeStyle = currentWeapon.color;
    weaponCtx.lineWidth = 3;

    weaponCtx.beginPath();
    // Simple gun shape with neon glow effect
    weaponCtx.shadowColor = currentWeapon.color;
    weaponCtx.shadowBlur = 12;
    weaponCtx.moveTo(40, 130);
    weaponCtx.lineTo(140, 130);
    weaponCtx.lineTo(140, 90);
    weaponCtx.lineTo(160, 90);
    weaponCtx.lineTo(160, 70);
    weaponCtx.lineTo(140, 70);
    weaponCtx.lineTo(140, 40);
    weaponCtx.lineTo(40, 40);
    weaponCtx.closePath();
    weaponCtx.stroke();

    if(currentWeapon.flamethrower) {
      weaponCtx.fillStyle = "rgba(255, 85, 0, 0.3)";
      weaponCtx.beginPath();
      weaponCtx.moveTo(160, 70);
      weaponCtx.lineTo(190, 90);
      weaponCtx.lineTo(160, 110);
      weaponCtx.closePath();
      weaponCtx.fill();
    }
  }

  // Bullet creation
  function shootBullet() {
    if(player.bulletCooldown > 0) return;
    player.bulletCooldown = 0.15;

    const bulletGeo = new THREE.SphereGeometry(currentWeapon.bulletSize, 6, 6);
    const bulletMat = new THREE.MeshBasicMaterial({color: currentWeapon.color});
    const bullet = new THREE.Mesh(bulletGeo, bulletMat);

    // Position bullet at camera position, moving forward
    bullet.position.copy(camera.position);
    bullet.userData = {
      velocity: new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).multiplyScalar(currentWeapon.bulletSpeed),
      damage: currentWeapon.damage,
      alive: true
    };
    scene.add(bullet);
    bullets.push(bullet);
  }
    // Handle collisions bullet <-> enemy
  function checkBulletEnemyCollisions() {
    bullets.forEach(bullet => {
      if(!bullet.userData.alive) return;
      enemies.forEach(enemy => {
        if(!enemy.userData.alive) return;
        const dist = bullet.position.distanceTo(enemy.position);
        if(dist < 0.7) {
          enemy.userData.hp -= bullet.userData.damage;
          bullet.userData.alive = false;
          scene.remove(bullet);
          if(enemy.userData.hp <= 0) {
            enemy.userData.alive = false;
            scene.remove(enemy);
          }
        }
      });
    });
    bullets = bullets.filter(b => b.userData.alive);
  }

  // Animate loop with fixed FPS calculation and debug log
  let lastFrameTime = performance.now();
  let frameCount = 0;
  let fps = 0;
  let fpsTimer = 0;

  function animate() {
    requestAnimationFrame(animate);
    const now = performance.now();
    deltaTime = (now - lastFrameTime) / 1000;
    lastFrameTime = now;

    // FPS calculation
    frameCount++;
    fpsTimer += deltaTime;

    if(fpsTimer >= 1) {
      fps = frameCount;
      fpsCounter.textContent = "FPS: " + fps;
      console.log("FPS:", fps);  // DEBUG: Check console for updates
      frameCount = 0;
      fpsTimer = 0;
    }

    // Player movement
    if(controls.isLocked === true) {
      const speed = player.speed * deltaTime;
      if(keys['w']) controls.moveForward(speed);
      if(keys['s']) controls.moveForward(-speed);
      if(keys['a']) controls.moveRight(-speed);
      if(keys['d']) controls.moveRight(speed);
    }

    // Update bullets
    bullets.forEach(bullet => {
      bullet.position.addScaledVector(bullet.userData.velocity, deltaTime);
      if(bullet.position.distanceTo(camera.position) > 100) {
        bullet.userData.alive = false;
        scene.remove(bullet);
      }
    });
    bullets = bullets.filter(b => b.userData.alive);

    checkBulletEnemyCollisions();

    // Simple enemy AI
    enemies.forEach(enemy => {
      if(!enemy.userData.alive) return;
      const dir = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize();
      enemy.position.addScaledVector(dir, 2 * deltaTime);
    });

    if(player.bulletCooldown > 0) {
      player.bulletCooldown -= deltaTime;
    }

    renderer.render(scene, camera);
  }

  // Input handling
  let keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if(e.key === ' ') e.preventDefault();
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  window.addEventListener('mousedown', e => {
    if(controls.isLocked) shootBullet();
  });

  // Setup fractal and rooms
  function setupGame(seedStr, depth) {
    // Clean up old scene children except camera and controls
    scene.children = scene.children.filter(child => child.type === "PerspectiveCamera" || child === controls.getObject());

    rng = new RNG(parseInt(seedStr) || 12345);
    fractalGroup = new THREE.Group();
    scene.add(fractalGroup);

    fractalGroup.add(createFractalTunnel(depth));

    enemies = [];
    for(let i=1; i<=depth; i++) {
      const room = createRoom(parseInt(seedStr), i);
      fractalGroup.add(room);
    }

    currentWeapon = generateWeapon(parseInt(seedStr));
    drawWeapon();

    controls.getObject().position.set(0, 0, 2);
    camera.position.copy(controls.getObject().position);
  }

  startBtn.onclick = () => {
    const seed = seedInput.value.trim() || "12345";
    const depth = Math.min(Math.max(parseInt(depthInput.value) || 3, 1), 10);
    setupGame(seed, depth);
  };

  function init() {
    initThree();
    clock = new THREE.Clock();
    animate();
  }

  init();
})();
</script>

</body>
</html>

