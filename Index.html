<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Fractal Portal FPS</title>
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden; background: black; color: #ddd;
    font-family: monospace, monospace;
    user-select: none;
  }
  #canvas3d {
    display: block; width: 100vw; height: 100vh; touch-action: none;
  }
  #ui {
    position: fixed; top: 8px; left: 8px; z-index: 20; 
    background: rgba(0,0,0,0.6); padding: 8px; border-radius: 6px; max-width: 300px;
  }
  #ui input {
    width: 120px; margin-right: 6px; background: #222; border: 1px solid #555; color: #eee; font-size: 14px; border-radius: 4px; padding: 3px;
  }
  #ui button {
    background: #444; border: none; padding: 6px 12px; border-radius: 4px; color: #eee;
    cursor: pointer;
  }
  #ui button:hover {
    background: #666;
  }
  #hud {
    position: fixed; bottom: 12px; left: 12px; color: #8af; font-size: 14px; 
    background: rgba(0,0,0,0.4); padding: 8px; border-radius: 6px; max-width: 90vw;
    font-family: monospace;
  }
</style>
</head>
<body>
<canvas id="canvas3d"></canvas>
<div id="ui">
  <label>Seed: <input id="seed" placeholder="integer seed" /></label>
  <label>Depth: <input id="depth" type="number" min="1" max="10" value="2" /></label>
  <button id="enterPortal">Enter Portal</button>
  <div style="margin-top:6px; font-size:12px; color:#aaa;">WASD + mouse to move/look (desktop). Touch drag to look (mobile).</div>
</div>
<div id="hud">
  <div id="health">Health: 100</div>
  <div id="weapon">Weapon: --</div>
  <div id="ammo">Ammo: âˆž</div>
  <div id="monsters">Monsters: 0</div>
</div>
<script>
"use strict";

// Basic utilities
function clamp(x,a,b){return x<a?a:x>b?b:x;}
function mix(a,b,t){return a*(1-t)+b*t;}
function smoothstep(edge0, edge1, x){
  let t = clamp((x-edge0)/(edge1-edge0),0,1);
  return t*t*(3-2*t);
}

// Deterministic RNG - XorShift32
class RNG {
  constructor(seed){
    this.state = seed >>> 0 || 0xdeadbeef;
  }
  next(){
    let x = this.state;
    x ^= x << 13;
    x ^= x >>> 17;
    x ^= x << 5;
    this.state = x >>> 0;
    return this.state;
  }
  float(){
    return (this.next() & 0xFFFFFF) / 0x1000000;
  }
  range(min,max){
    return min + (this.next() % (max - min));
  }
  int(max){
    return this.next() % max;
  }
}

// --- WebGL setup ---

const canvas = document.getElementById('canvas3d');
const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
if(!gl){
  alert("WebGL not supported");
}

let W, H;
function resize(){
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  gl.viewport(0, 0, W, H);
}
window.addEventListener('resize', resize);
resize();

// Vertex shader (full screen quad)
const vsSource = `#version 300 es
precision highp float;
in vec2 aPos;
out vec2 vUv;
void main(){
  vUv = aPos * 0.5 + 0.5;
  gl_Position = vec4(aPos,0.0,1.0);
}
`;

// Fragment shader (raymarch Mandelbulb fractal with recursion and lighting)
const fsSource = `#version 300 es
precision highp float;

in vec2 vUv;
out vec4 outColor;

uniform vec2 uRes;
uniform float uTime;
uniform vec3 uCamPos;
uniform vec3 uCamDir;
uniform vec3 uCamRight;
uniform vec3 uCamUp;

uniform int uMaxSteps;
uniform float uMaxDist;
uniform float uMinDist;
uniform int uPower;
uniform vec3 uFractalOffset;

#define MAX_ITER 15

// Mandelbulb distance estimator (power controls fractal depth)
float mandelbulbDE(vec3 pos, int power){
  vec3 z = pos;
  float dr = 1.0;
  float r = 0.0;
  for(int i=0; i<MAX_ITER; i++){
    r = length(z);
    if(r > 2.0) break;

    // convert to polar coords
    float theta = acos(z.z/r);
    float phi = atan(z.y,z.x);
    dr =  pow(r, power-1.0)*power*dr + 1.0;

    // scale and rotate the point
    float zr = pow(r, float(power));
    theta *= float(power);
    phi *= float(power);

    z = zr * vec3(
      sin(theta)*cos(phi),
      sin(phi)*sin(theta),
      cos(theta)
    ) + pos;
  }
  return 0.5*log(r)*r/dr;
}

// Estimate normal by gradient
vec3 estimateNormal(vec3 p){
  float e = 0.001;
  return normalize(vec3(
    mandelbulbDE(p+vec3(e,0,0), uPower) - mandelbulbDE(p-vec3(e,0,0), uPower),
    mandelbulbDE(p+vec3(0,e,0), uPower) - mandelbulbDE(p-vec3(0,e,0), uPower),
    mandelbulbDE(p+vec3(0,0,e), uPower) - mandelbulbDE(p-vec3(0,0,e), uPower)
  ));
}

// Raymarching function
float rayMarch(vec3 ro, vec3 rd, out vec3 pHit){
  float dist = 0.0;
  for(int i=0; i<uMaxSteps; i++){
    vec3 p = ro + rd*dist;
    float d = mandelbulbDE(p - uFractalOffset, uPower);
    if(d < uMinDist){
      pHit = p;
      return dist;
    }
    if(dist > uMaxDist) break;
    dist += d;
  }
  pHit = vec3(0.0);
  return -1.0;
}

// Simple Phong lighting
vec3 lighting(vec3 p, vec3 n, vec3 lightPos, vec3 camPos){
  vec3 lightDir = normalize(lightPos - p);
  float diff = max(dot(n, lightDir), 0.0);
  vec3 viewDir = normalize(camPos - p);
  vec3 reflectDir = reflect(-lightDir, n);
  float spec = pow(max(dot(viewDir, reflectDir),0.0),16.0);
  vec3 ambient = vec3(0.08,0.1,0.14);
  vec3 diffuse = vec3(0.7,0.4,1.0) * diff;
  vec3 specular = vec3(0.8,0.7,1.0) * spec;
  return ambient + diffuse + specular;
}

void main(){
  // Camera ray
  vec2 uv = (vUv - 0.5) * vec2(uRes.x/uRes.y, 1.0);
  vec3 ro = uCamPos;
  vec3 rd = normalize(uCamDir + uv.x*uCamRight + uv.y*uCamUp);

  vec3 hitPos;
  float dist = rayMarch(ro, rd, hitPos);

  if(dist > 0.0){
    vec3 n = estimateNormal(hitPos);
    vec3 color = lighting(hitPos, n, vec3(10,10,10), ro);
    // Apply some color shift by fractal offset seed (for variety)
    color *= 0.5 + 0.5*sin(uFractalOffset.x*12.0 + dist*4.0);
    outColor = vec4(color, 1.0);
  } else {
    // Background: swirling colors based on direction + time
    vec3 bg = 0.3 + 0.7 * vec3(
      0.5 + 0.5*sin(uTime + uv.x*12.0),
      0.5 + 0.5*cos(uTime + uv.y*12.0),
      0.5 + 0.5*sin(uTime*1.5)
    );
    outColor = vec4(bg,1.0);
  }
}
`;

// Compile shaders & link program
function createShader(gl, type, source){
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
    console.error("Shader compile failed:", gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}
function createProgram(gl, vsSource, fsSource){
  const program = gl.createProgram();
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  if(!vs || !fs) return null;
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
    console.error("Program link failed:", gl.getProgramInfoLog(program));
    return null;
  }
  return program;
}

const program = createProgram(gl, vsSource, fsSource);
if(!program) throw new Error("Failed to create shader program");

const aPos = gl.getAttribLocation(program, "aPos");
const uRes = gl.getUniformLocation(program, "uRes");
const uTime = gl.getUniformLocation(program, "uTime");
const uCamPos = gl.getUniformLocation(program, "uCamPos");
const uCamDir = gl.getUniformLocation(program, "uCamDir");
const uCamRight = gl.getUniformLocation(program, "uCamRight");
const uCamUp = gl.getUniformLocation(program, "uCamUp");
const uMaxSteps = gl.getUniformLocation(program, "uMaxSteps");
const uMaxDist = gl.getUniformLocation(program, "uMaxDist");
const uMinDist = gl.getUniformLocation(program, "uMinDist");
const uPower = gl.getUniformLocation(program, "uPower");
const uFractalOffset = gl.getUniformLocation(program, "uFractalOffset");

// Create buffer for fullscreen quad
const quadBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1, 1,-1, -1,1,
  -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);

// --- Camera & controls ---
const cam = {
  pos: [0, 0, 4],
  pitch: 0,
  yaw: 0,
  speed: 2.5,
  sensitivity: 0.003,
  keys: {},
  velocity: [0,0,0],
  forward: [0,0,-1],
  right: [1,0,0],
  up: [0,1,0],
  lastX: null,
  lastY: null,
  dragging: false,
};

function updateCamVectors(){
  const cosPitch = Math.cos(cam.pitch);
  const sinPitch = Math.sin(cam.pitch);
  const cosYaw = Math.cos(cam.yaw);
  const sinYaw = Math.sin(cam.yaw);
  cam.forward[0] = sinYaw * cosPitch;
  cam.forward[1] = sinPitch;
  cam.forward[2] = -cosYaw * cosPitch;
  cam.right[0] = cosYaw;
  cam.right[1] = 0;
  cam.right[2] = sinYaw;
  cam.up[0] = -sinPitch * sinYaw;
  cam.up[1] = cosPitch;
  cam.up[2] = cosYaw * sinPitch;
}
updateCamVectors();

// Keyboard input
window.addEventListener('keydown', e=>{
  cam.keys[e.code] = true;
});
window.addEventListener('keyup', e=>{
  cam.keys[e.code] = false;
});

// Mouse input for look
canvas.addEventListener('pointerdown', e=>{
  cam.dragging = true;
  cam.lastX = e.clientX;
  cam.lastY = e.clientY;
  canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener('pointermove', e=>{
  if(cam.dragging){
    const dx = e.clientX - cam.lastX;
    const dy = e.clientY - cam.lastY;
    cam.yaw -= dx * cam.sensitivity;
    cam.pitch -= dy * cam.sensitivity;
    cam.pitch = clamp(cam.pitch, -Math.PI/2 + 0.01, Math.PI/2 - 0.01);
    updateCamVectors();
    cam.lastX = e.clientX;
    cam.lastY = e.clientY;
  }
});
canvas.addEventListener('pointerup', e=>{
  cam.dragging = false;
  canvas.releasePointerCapture(e.pointerId);
});

// Touch for mobile look
canvas.addEventListener('touchstart', e=>{
  if(e.touches.length === 1){
    cam.dragging = true;
    cam.lastX = e.touches[0].clientX;
    cam.lastY = e.touches[0].clientY;
  }
});
canvas.addEventListener('touchmove', e=>{
  if(cam.dragging && e.touches.length === 1){
    const dx = e.touches[0].clientX - cam.lastX;
    const dy = e.touches[0].clientY - cam.lastY;
    cam.yaw -= dx * cam.sensitivity * 0.8;
    cam.pitch -= dy * cam.sensitivity * 0.8;
    cam.pitch = clamp(cam.pitch, -Math.PI/2 + 0.01, Math.PI/2 - 0.01);
    updateCamVectors();
    cam.lastX = e.touches[0].clientX;
    cam.lastY = e.touches[0].clientY;
    e.preventDefault();
  }
});
canvas.addEventListener('touchend', e=>{
  cam.dragging = false;
});

// Player & Game state
const rng = new RNG(0);
let seed = 0;
let depth = 2;

const player = {
  pos: [0,0,4],
  health: 100,
  radius: 0.3,
};

let weapon = null;
let monsters = [];
let projectiles = [];
let lastShot = 0;

// Weapon generator
const weaponTypes = [
  {
    name: "Bullet Gun",
    fireRateBase: 6,
    dmgBase: 12,
    fireMode: "bullet",
    colorBase: [0.9,0.9,0.7],
    shoot: function(origin, dir){
      projectiles.push({
        pos: origin.slice(),
        dir: dir.slice(),
        speed: 10,
        dmg: weapon.dmg,
        radius: 0.05,
        color: weapon.color,
        life: 2.5,
      });
    }
  },
  {
    name: "Laser Beam",
    fireRateBase: 10,
    dmgBase: 3,
    fireMode: "beam",
    colorBase: [0.5,0.8,1.0],
    shoot: function(origin, dir){
      projectiles.push({
        pos: origin.slice(),
        dir: dir.slice(),
        speed: 20,
        dmg: weapon.dmg,
        radius: 0.02,
        color: weapon.color,
        life: 1.5,
        beam: true,
      });
    }
  },
  {
    name: "Flamethrower",
    fireRateBase: 20,
    dmgBase: 1,
    fireMode: "spray",
    colorBase: [1.0,0.5,0.2],
    shoot: function(origin, dir){
      // spray some short-lived particles
      for(let i=0; i<3; i++){
        let spreadAngle = (Math.random()-0.5)*0.3;
        let c = Math.cos(spreadAngle);
        let s = Math.sin(spreadAngle);
        let dx = dir[0]*c - dir[2]*s;
        let dz = dir[0]*s + dir[2]*c;
        let spreadDir = [dx, dir[1], dz];
        projectiles.push({
          pos: origin.slice(),
          dir: spreadDir,
          speed: 7 + Math.random()*3,
          dmg: weapon.dmg,
          radius: 0.04,
          color: weapon.color,
          life: 0.8 + Math.random()*0.4,
        });
      }
    }
  }
];

// Generate weapon from seed & depth
function genWeapon(seed, depth){
  const wRNG = new RNG(seed ^ (depth*12345));
  const type = weaponTypes[wRNG.int(weaponTypes.length)];
  const dmg = type.dmgBase * (1 + wRNG.float()*0.8 + depth*0.15);
  const rate
