<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Fractal Portal Prototype (WebGL)</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#ddd;font-family:Inter,Arial}
  canvas{display:block;touch-action:none}
  #ui{position:fixed;left:8px;top:8px;z-index:30;display:flex;flex-direction:row;gap:8px;align-items:center}
  #panel{backdrop-filter:blur(6px);background:rgba(0,0,0,0.25);padding:8px;border-radius:8px}
  input,button{font-size:14px;padding:6px;border-radius:6px;border:1px solid #444;background:#111;color:#ddd}
  #log{position:fixed;left:8px;bottom:8px;z-index:30;max-width:60%;padding:8px;background:rgba(0,0,0,0.25);border-radius:8px;font-size:13px}
  #help{position:fixed;right:8px;top:8px;z-index:30;padding:8px;background:rgba(0,0,0,0.25);border-radius:8px;font-size:13px}
  @media (min-width:800px){#log{max-width:40%}}
</style>
</head>
<body>
<canvas id="gl"></canvas>
<canvas id="game"></canvas>

<div id="ui">
  <div id="panel">
    Seed: <input id="seed" placeholder="random" style="width:110px">
    Depth: <input id="depth" value="1" style="width:50px">
    <button id="enter">Enter Portal</button>
  </div>
</div>

<div id="help">Drag to move (left side). Tap/click to shoot (right side). Seed + depth deterministic.</div>
<div id="log">Welcome â€” enter a seed and press Enter Portal.</div>

<script>
/* -------------------------
   Simple deterministic RNG
   ------------------------- */
function XorShift32(seed){
  this.state = (seed >>> 0) || 0xdeadbeef;
}
XorShift32.prototype.next = function(){
  let x = this.state;
  x ^= (x << 13);
  x ^= (x >>> 17);
  x ^= (x << 5);
  this.state = x >>> 0;
  return this.state;
};
XorShift32.prototype.float = function(){ return (this.next() & 0xFFFFFF) / 0x1000000; };
XorShift32.prototype.range = function(a,b){ return a + (this.next() % (b-a)); };

/* -------------------------
   WebGL fractal background
   ------------------------- */
const glCanvas = document.getElementById('gl');
const gl = glCanvas.getContext('webgl', {preserveDrawingBuffer:false});
const vs = `
attribute vec2 aPos;
varying vec2 vUv;
void main(){ vUv = aPos * 0.5 + 0.5; gl_Position = vec4(aPos,0.0,1.0); }`;
const fs = `
precision mediump float;
uniform vec2 uRes;
uniform float uTime;
uniform vec2 uCenter;
uniform float uZoom;
uniform float uSeed;
uniform int uMode; // 0 mandelbrot-ish, 1 julia
varying vec2 vUv;

float hash(float x){ return fract(sin(x)*43758.5453); }

void main(){
  vec2 uv = (vUv - 0.5) * (uRes.x/uRes.y);
  vec2 z = (uv - uCenter) / uZoom;
  vec2 c;
  if(uMode==1){
    float sx = fract(uSeed*0.0001);
    float sy = fract(uSeed*0.00013);
    c = vec2(-0.7 + sx*1.2, 0.27015 + sy*0.9);
  } else {
    c = z;
    z = vec2(0.0);
  }
  int maxIt = 120;
  float iter = 0.0;
  for(int i=0;i<120;i++){
    if(i>=maxIt) break;
    float x = (z.x*z.x - z.y*z.y) + c.x;
    float y = (2.0*z.x*z.y) + c.y;
    z = vec2(x,y);
    if(dot(z,z) > 4.0){ iter = float(i); break; }
  }
  float t = iter/float(maxIt);
  // color mapping with time sway and seed
  float r = 0.15 + 0.85 * pow(t, 0.8) * (0.5+0.5*sin(0.6*uTime + uSeed*0.0002));
  float g = 0.05 + 0.95 * pow(t, 0.6) * (0.5+0.5*sin(0.9*uTime + uSeed*0.0005));
  float b = 0.05 + 0.95 * pow(t, 1.1) * (0.5+0.5*cos(0.5*uTime + uSeed*0.0007));
  vec3 col = mix(vec3(0.01,0.01,0.03), vec3(r,g,b), t);
  // subtle glow rings from log
  float glow = exp(-5.0*abs(t-0.15));
  col += 0.12*glow;
  gl_FragColor = vec4(col,1.0);
}
`;
function createShader(gl, src, type){
  const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(s)); return null; }
  return s;
}
function createProgram(gl, vsSrc, fsSrc){
  const p = gl.createProgram();
  const a = createShader(gl, vsSrc, gl.VERTEX_SHADER);
  const b = createShader(gl, fsSrc, gl.FRAGMENT_SHADER);
  gl.attachShader(p,a); gl.attachShader(p,b); gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(p)); return null; }
  return p;
}
const program = createProgram(gl, vs, fs);
const aPos = gl.getAttribLocation(program, 'aPos');
const uRes = gl.getUniformLocation(program, 'uRes');
const uTime = gl.getUniformLocation(program, 'uTime');
const uCenter = gl.getUniformLocation(program, 'uCenter');
const uZoom = gl.getUniformLocation(program, 'uZoom');
const uSeed = gl.getUniformLocation(program, 'uSeed');
const uMode = gl.getUniformLocation(program, 'uMode');
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

/* -------------------------
   Game canvas (2D) - sprites
   ------------------------- */
const gameCanvas = document.getElementById('game');
const gtx = gameCanvas.getContext('2d', {alpha:true});
let W = 1, H = 1;

function resize(){
  W = glCanvas.width = window.innerWidth;
  H = glCanvas.height = window.innerHeight;
  gameCanvas.width = W; gameCanvas.height = H;
  gl.viewport(0,0,W,H);
}
window.addEventListener('resize', resize);
resize();

/* -------------------------
   Simple game state
   ------------------------- */
const logEl = document.getElementById('log');
function log(s){ logEl.textContent = s; }

let state = {
  seed: Math.floor(Math.random()*999999),
  depth: 1,
  zoom: 1.0,
  center: {x:0,y:0},
  mode: 1, // julia-like
  time: 0,
  rng: new XorShift32(1234),
  player: {x: W/2, y: H*0.6, r:14, speed: 220, hp:100},
  weapon: null,
  monsters: [],
  projectiles: [],
  touch: {active:false, x:0, y:0, startX:0, startY:0, id:null},
  leftControl: {active:false, x:0, y:0},
  lastShot: 0
};

/* -------------------------
   Weapon & monster generators
   ------------------------- */
const PARTS = {
  cores: [
    {id:'core_small', arche:'projectile', dmg:4, rate:1.2, color:[0.9,0.6,0.2]},
    {id:'core_heavy', arche:'projectile', dmg:9, rate:0.6, color:[0.9,0.2,0.2]},
    {id:'core_beam', arche:'beam', dmg:2, rate:8, color:[0.2,0.9,0.6]}
  ],
  barrels: [
    {id:'bar_rel', dmg:0.0, rate:1.0, color:[0.8,0.8,0.8]},
    {id:'bar_spread', dmg:-1, rate:0.9, color:[0.6,0.9,0.6]},
    {id:'bar_long', dmg:+1, rate:0.95, color:[0.7,0.7,0.95]}
  ],
  crystals: [
    {id:'cry_fire', mod:1.1, color:[1.0,0.5,0.1]},
    {id:'cry_ice', mod:1.0, color:[0.5,0.9,1.0]},
    {id:'cry_void', mod:1.3, color:[0.8,0.4,0.9]}
  ],
  effects: [
    {id:'ef_none'},
    {id:'ef_chain'},
    {id:'ef_slow'}
  ]
};

function genWeapon(seed, depth){
  const rng = new XorShift32(seed ^ (depth*7919));
  const core = PARTS.cores[rng.next() % PARTS.cores.length];
  const bar = PARTS.barrels[rng.next() % PARTS.barrels.length];
  const cry = PARTS.crystals[rng.next() % PARTS.crystals.length];
  const eff = PARTS.effects[rng.next() % PARTS.effects.length];
  // aggregate stats
  let dmg = Math.max(1, core.dmg + bar.dmg);
  let rate = Math.max(0.08, core.rate * bar.rate);
  dmg *= cry.mod;
  // cosmetic color blend
  const color = [
    (core.color[0]+bar.color[0]+cry.color[0])/3,
    (core.color[1]+bar.color[1]+cry.color[1])/3,
    (core.color[2]+bar.color[2]+cry.color[2])/3
  ];
  return {name:`W-${seed%10000}`, dmg:dmg, rate:rate, color:color, effect:eff.id, arche:core.arche};
}

const MON_FAMILIES = [
  {id:'cryst', baseHp:8, baseDmg:3},
  {id:'wrig', baseHp:5, baseDmg:2},
  {id:'spect', baseHp:12, baseDmg:4}
];

function genMonsters(seed, depth, count){
  const rng = new XorShift32(seed ^ (depth*1337));
  const arr = [];
  for(let i=0;i<count;i++){
    const mf = MON_FAMILIES[rng.next() % MON_FAMILIES.length];
    const scale = 1 + rng.float()*0.9 + depth*0.2;
    const hp = Math.round(mf.baseHp * scale * (1 + rng.float()*0.6));
    const dmg = Math.round(mf.baseDmg * scale * (1 + rng.float()*0.4));
    const x = Math.floor(rng.float()*(W*0.8) + W*0.1);
    const y = Math.floor(rng.float()*(H*0.5) + H*0.05);
    arr.push({id:mf.id, x:x, y:y, hp:hp, maxHp:hp, dmg:dmg, r:10 + Math.round(scale*6), seed: rng.next()});
  }
  return arr;
}

/* -------------------------
   Controls & input
   ------------------------- */
let pointerDown = false;
gameCanvas.addEventListener('pointerdown', e=>{
  const rect = gameCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  if(x < W*0.45){ // left-half = movement control
    state.leftControl.active = true;
    state.leftControl.x = x; state.leftControl.y = y;
    state.touch.id = e.pointerId;
  } else {
    // right-half = shoot toward x,y
    spawnProjectileTowards(x,y);
  }
});
gameCanvas.addEventListener('pointermove', e=>{
  if(state.leftControl.active && e.pointerId===state.touch.id){
    const rect = gameCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    // move vector from initial to current
    const dx = x - state.leftControl.x, dy = y - state.leftControl.y;
    // normalize and apply
    const max = 80;
    const nx = Math.max(-1,Math.min(1,dx/max));
    const ny = Math.max(-1,Math.min(1,dy/max));
    state.player.vx = nx * state.player.speed;
    state.player.vy = ny * state.player.speed;
  }
});
gameCanvas.addEventListener('pointerup', e=>{
  if(e.pointerId===state.touch.id){ state.leftControl.active=false; state.player.vx=0; state.player.vy=0; state.touch.id=null; }
});

/* -------------------------
   Projectiles
   ------------------------- */
function spawnProjectileTowards(tx,ty){
  const now = performance.now();
  if(now - state.lastShot < (1000 / (state.weapon.rate || 1))) return;
  state.lastShot = now;
  const dx = tx - state.player.x, dy = ty - state.player.y;
  const len = Math.hypot(dx,dy) || 1;
  const speed = 420;
  const vx = dx/len * speed, vy = dy/len * speed;
  state.projectiles.push({x: state.player.x, y: state.player.y, vx: vx, vy: vy, r:6, dmg: state.weapon.dmg, life: 2200, created: now, color: state.weapon.color});
}

/* -------------------------
   Enter portal (seed)
   ------------------------- */
const seedInput = document.getElementById('seed');
const depthInput = document.getElementById('depth');
document.getElementById('enter').addEventListener('click', ()=>{
  let s = parseInt(seedInput.value);
  if(!Number.isFinite(s)) s = Math.floor(Math.random()*999999);
  const d = Math.max(1, parseInt(depthInput.value) || 1);
  enterPortal(s, d);
});

function enterPortal(seed, depth){
  state.seed = seed; state.depth = depth;
  state.zoom = 1.0 + depth*0.8;
  state.mode = (depth%2===0)?0:1;
  state.rng = new XorShift32(seed ^ depth*9973);
  state.weapon = genWeapon(seed, depth);
  state.monsters = genMonsters(seed, depth, 5 + depth*2);
  state.projectiles = [];
  // position player middle bottom
  state.player.x = W/2; state.player.y = H*0.75;
  // set shader uniforms
  gl.useProgram(program);
  gl.uniform1f(uSeed, state.seed);
  gl.uniform1i(uMode, state.mode);
  log(`Seed ${seed} | Depth ${depth} | Weapon ${state.weapon.name} dmg:${state.weapon.dmg.toFixed(1)} rate:${state.weapon.rate.toFixed(2)} effect:${state.weapon.effect}`);
}

/* -------------------------
   Update loop
   ------------------------- */
let last = performance.now();
function step(t){
  const dt = Math.min(50, t - last);
  last = t;
  state.time += dt*0.001;

  // gradually nudge fractal center for slight motion
  state.center.x *= 0.98; state.center.y *= 0.98;

  // move player by velocity
  if(state.player.vx) state.player.x += state.player.vx * dt/1000;
  if(state.player.vy) state.player.y += state.player.vy * dt/1000;
  // clamp to screen
  state.player.x = Math.max(20, Math.min(W-20, state.player.x));
  state.player.y = Math.max(20, Math.min(H-20, state.player.y));

  // update projectiles
  for(let i=state.projectiles.length-1;i>=0;i--){
    const p = state.projectiles[i];
    p.x += p.vx * dt/1000; p.y += p.vy * dt/1000;
    p.life -= dt;
    if(p.life <= 0 || p.x<-50 || p.x>W+50 || p.y<-50 || p.y>H+50){ state.projectiles.splice(i,1); continue; }
    // collision with monsters
    for(let j=state.monsters.length-1;j>=0;j--){
      const m = state.monsters[j];
      const dx = p.x - m.x, dy = p.y - m.y;
      if(dx*dx + dy*dy < (p.r + m.r)*(p.r + m.r)){
        m.hp -= p.dmg;
        // small effect: push monster
        const mag = Math.hypot(dx,dy)||1; m.x += (dx/mag)*6; m.y += (dy/mag)*6;
        state.projectiles.splice(i,1);
        if(m.hp<=0){ state.monsters.splice(j,1); break; }
        break;
      }
    }
  }

  // monster AI: simple move toward player
  for(let m of state.monsters){
    const dx = state.player.x - m.x, dy = state.player.y - m.y;
    const dist = Math.hypot(dx,dy)||1;
    const speed = 30 + (state.depth*6);
    m.x += (dx/dist) * speed * dt/1000;
    m.y += (dy/dist) * speed * dt/1000;
    // if close, damage player over time
    if(dist < m.r + state.player.r + 6){
      state.player.hp -= (m.dmg * dt/1000);
      if(state.player.hp<=0){ state.player.hp = 0; log('You died â€” enter another portal to restart.'); }
    }
  }

  // slowly reduce zoom (simulate deeper fractal pull)
  state.zoom *= 1.0 - (0.0005 * state.depth);

  renderGL();
  renderGame();
  requestAnimationFrame(step);
}

/* -------------------------
   Render WebGL fractal
   ------------------------- */
function renderGL(){
  gl.useProgram(program);
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);
  gl.uniform2f(uRes, W, H);
  gl.uniform1f(uTime, state.time);
  // uCenter: convert to fractal coordinate small nudges
  gl.uniform2f(uCenter, state.center.x*0.001, state.center.y*0.001);
  gl.uniform1f(uZoom, state.zoom);
  gl.uniform1f(uSeed, state.seed);
  gl.uniform1i(uMode, state.mode);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

/* -------------------------
   Render game objects (2D)
   ------------------------- */
function renderGame(){
  gtx.clearRect(0,0,W,H);
  // player
  gtx.beginPath();
  gtx.fillStyle = '#fff';
  gtx.arc(state.player.x, state.player.y, state.player.r, 0, Math.PI*2);
  gtx.fill();
  // player HP bar
  gtx.fillStyle = 'rgba(0,0,0,0.5)';
  gtx.fillRect(12,12,180,12);
  gtx.fillStyle = '#6af';
  gtx.fillRect(12,12, 180 * (state.player.hp/100), 12);
  gtx.strokeStyle='#111'; gtx.strokeRect(12,12,180,12);

  // monsters
  for(let m of state.monsters){
    // health ring
    const hpf = Math.max(0, m.hp/m.maxHp);
    gtx.beginPath();
    gtx.fillStyle = 'rgba(255,100,80,0.14)';
    gtx.arc(m.x, m.y, m.r+6, 0, Math.PI*2); gtx.fill();
    // body
    gtx.beginPath();
    gtx.fillStyle = '#ff6';
    if(m.id==='cryst') gtx.fillStyle = '#8ff';
    if(m.id==='spect') gtx.fillStyle = '#b6a';
    gtx.arc(m.x, m.y, m.r, 0, Math.PI*2); gtx.fill();
    // hp text
    gtx.fillStyle = '#000';
    gtx.font = '12px Arial';
    gtx.fillText(Math.max(0,Math.round(m.hp)), m.x-8, m.y+4);
  }

  // projectiles
  for(let p of state.projectiles){
    gtx.beginPath();
    gtx.fillStyle = `rgba(${Math.floor(p.color[0]*255)},${Math.floor(p.color[1]*255)},${Math.floor(p.color[2]*255)},0.95)`;
    gtx.arc(p.x, p.y, p.r, 0, Math.PI*2); gtx.fill();
  }

  // UI small: weapon info
  gtx.fillStyle = 'rgba(0,0,0,0.35)';
  gtx.fillRect(12,36,260,62);
  gtx.fillStyle = '#fff';
  gtx.font = '13px Arial';
  gtx.fillText(`Weapon: ${state.weapon.name || '---'}`, 18, 54);
  gtx.fillText(`Dmg: ${state.weapon.dmg.toFixed(1)}  Rate: ${state.weapon.rate.toFixed(2)}  Effect: ${state.weapon.effect}`, 18, 74);
}

/* -------------------------
   Start
   ------------------------- */
enterPortal(state.seed, state.depth);
requestAnimationFrame(step);
</script>
</body>
</html>